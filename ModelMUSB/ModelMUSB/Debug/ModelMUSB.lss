
ModelMUSB.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002450  00080000  00080000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000638  20070000  00082450  00010000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          00000100  20070638  00082a88  00010638  2**2
                  ALLOC
  3 .stack        00002000  20070738  00082b88  00010638  2**0
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  00010638  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010661  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000ac94  00000000  00000000  000106bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000211c  00000000  00000000  0001b350  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000720  00000000  00000000  0001d46c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00018eef  00000000  00000000  0001db8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000dfb3  00000000  00000000  00036a7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0006bfe0  00000000  00000000  00044a2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00004283  00000000  00000000  000b0a0e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000006c8  00000000  00000000  000b4c91  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  0000106c  00000000  00000000  000b535c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	20072738 	.word	0x20072738
   80004:	000820cd 	.word	0x000820cd
   80008:	000820c9 	.word	0x000820c9
   8000c:	000820c9 	.word	0x000820c9
   80010:	000820c9 	.word	0x000820c9
   80014:	000820c9 	.word	0x000820c9
   80018:	000820c9 	.word	0x000820c9
	...
   8002c:	000820c9 	.word	0x000820c9
   80030:	000820c9 	.word	0x000820c9
   80034:	00000000 	.word	0x00000000
   80038:	000820c9 	.word	0x000820c9
   8003c:	000820c9 	.word	0x000820c9
   80040:	000820c9 	.word	0x000820c9
   80044:	000820c9 	.word	0x000820c9
   80048:	000820c9 	.word	0x000820c9
   8004c:	000820c9 	.word	0x000820c9
   80050:	000820c9 	.word	0x000820c9
   80054:	000820c9 	.word	0x000820c9
   80058:	000820c9 	.word	0x000820c9
   8005c:	000820c9 	.word	0x000820c9
   80060:	000820c9 	.word	0x000820c9
   80064:	000820c9 	.word	0x000820c9
   80068:	00000000 	.word	0x00000000
   8006c:	00081edd 	.word	0x00081edd
   80070:	00081ef1 	.word	0x00081ef1
   80074:	00081f05 	.word	0x00081f05
   80078:	00081f19 	.word	0x00081f19
	...
   80084:	000820c9 	.word	0x000820c9
   80088:	000820c9 	.word	0x000820c9
   8008c:	000820c9 	.word	0x000820c9
   80090:	000820c9 	.word	0x000820c9
   80094:	000820c9 	.word	0x000820c9
   80098:	000820c9 	.word	0x000820c9
   8009c:	000820c9 	.word	0x000820c9
   800a0:	000820c9 	.word	0x000820c9
   800a4:	00000000 	.word	0x00000000
   800a8:	000820c9 	.word	0x000820c9
   800ac:	000820c9 	.word	0x000820c9
   800b0:	000820c9 	.word	0x000820c9
   800b4:	000820c9 	.word	0x000820c9
   800b8:	000820c9 	.word	0x000820c9
   800bc:	000820c9 	.word	0x000820c9
   800c0:	000820c9 	.word	0x000820c9
   800c4:	000820c9 	.word	0x000820c9
   800c8:	000820c9 	.word	0x000820c9
   800cc:	000820c9 	.word	0x000820c9
   800d0:	000820c9 	.word	0x000820c9
   800d4:	000820c9 	.word	0x000820c9
   800d8:	000820c9 	.word	0x000820c9
   800dc:	000820c9 	.word	0x000820c9
   800e0:	00080ee5 	.word	0x00080ee5
   800e4:	000820c9 	.word	0x000820c9
   800e8:	000820c9 	.word	0x000820c9
   800ec:	000820c9 	.word	0x000820c9
   800f0:	000820c9 	.word	0x000820c9

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20070638 	.word	0x20070638
   80110:	00000000 	.word	0x00000000
   80114:	00082450 	.word	0x00082450

00080118 <frame_dummy>:
   80118:	4b08      	ldr	r3, [pc, #32]	; (8013c <frame_dummy+0x24>)
   8011a:	b510      	push	{r4, lr}
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4808      	ldr	r0, [pc, #32]	; (80140 <frame_dummy+0x28>)
   80120:	4908      	ldr	r1, [pc, #32]	; (80144 <frame_dummy+0x2c>)
   80122:	f3af 8000 	nop.w
   80126:	4808      	ldr	r0, [pc, #32]	; (80148 <frame_dummy+0x30>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b903      	cbnz	r3, 8012e <frame_dummy+0x16>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	4b07      	ldr	r3, [pc, #28]	; (8014c <frame_dummy+0x34>)
   80130:	2b00      	cmp	r3, #0
   80132:	d0fb      	beq.n	8012c <frame_dummy+0x14>
   80134:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80138:	4718      	bx	r3
   8013a:	bf00      	nop
   8013c:	00000000 	.word	0x00000000
   80140:	00082450 	.word	0x00082450
   80144:	2007063c 	.word	0x2007063c
   80148:	00082450 	.word	0x00082450
   8014c:	00000000 	.word	0x00000000

00080150 <udi_hid_kbd_disable>:
	return UDI_HID_KBD_ENABLE_EXT();
}


void udi_hid_kbd_disable(void)
{
   80150:	4770      	bx	lr
   80152:	bf00      	nop

00080154 <udi_hid_kbd_getsetting>:


uint8_t udi_hid_kbd_getsetting(void)
{
	return 0;
}
   80154:	2000      	movs	r0, #0
   80156:	4770      	bx	lr

00080158 <udi_hid_kbd_setreport>:


static bool udi_hid_kbd_setreport(void)
{
	if ((USB_HID_REPORT_TYPE_OUTPUT == (udd_g_ctrlreq.req.wValue >> 8))
   80158:	4b0c      	ldr	r3, [pc, #48]	; (8018c <udi_hid_kbd_setreport+0x34>)
   8015a:	885b      	ldrh	r3, [r3, #2]
   8015c:	0a1a      	lsrs	r2, r3, #8
   8015e:	2a02      	cmp	r2, #2
   80160:	d10e      	bne.n	80180 <udi_hid_kbd_setreport+0x28>
			&& (0 == (0xFF & udd_g_ctrlreq.req.wValue))
   80162:	f013 0fff 	tst.w	r3, #255	; 0xff
   80166:	d10d      	bne.n	80184 <udi_hid_kbd_setreport+0x2c>
			&& (1 == udd_g_ctrlreq.req.wLength)) {
   80168:	4b08      	ldr	r3, [pc, #32]	; (8018c <udi_hid_kbd_setreport+0x34>)
   8016a:	88db      	ldrh	r3, [r3, #6]
   8016c:	2b01      	cmp	r3, #1
   8016e:	d10b      	bne.n	80188 <udi_hid_kbd_setreport+0x30>
		// Report OUT type on report ID 0 from USB Host
		udd_g_ctrlreq.payload = &udi_hid_kbd_report_set;
   80170:	4b06      	ldr	r3, [pc, #24]	; (8018c <udi_hid_kbd_setreport+0x34>)
   80172:	4a07      	ldr	r2, [pc, #28]	; (80190 <udi_hid_kbd_setreport+0x38>)
   80174:	609a      	str	r2, [r3, #8]
		udd_g_ctrlreq.callback = udi_hid_kbd_setreport_valid;
   80176:	4a07      	ldr	r2, [pc, #28]	; (80194 <udi_hid_kbd_setreport+0x3c>)
   80178:	611a      	str	r2, [r3, #16]
		udd_g_ctrlreq.payload_size = 1;
   8017a:	2001      	movs	r0, #1
   8017c:	8198      	strh	r0, [r3, #12]
		return true;
   8017e:	4770      	bx	lr
	}
	return false;
   80180:	2000      	movs	r0, #0
   80182:	4770      	bx	lr
   80184:	2000      	movs	r0, #0
   80186:	4770      	bx	lr
   80188:	2000      	movs	r0, #0
}
   8018a:	4770      	bx	lr
   8018c:	20070720 	.word	0x20070720
   80190:	2007065c 	.word	0x2007065c
   80194:	00080199 	.word	0x00080199

00080198 <udi_hid_kbd_setreport_valid>:
		udi_hid_kbd_send_report();
	}
}

static void udi_hid_kbd_setreport_valid(void)
{
   80198:	4770      	bx	lr
   8019a:	bf00      	nop

0008019c <udi_hid_kbd_enable>:
//------ Interface for UDI HID level

bool udi_hid_kbd_enable(void)
{
	// Initialize internal values
	udi_hid_kbd_rate = 0;
   8019c:	2300      	movs	r3, #0
   8019e:	4a06      	ldr	r2, [pc, #24]	; (801b8 <udi_hid_kbd_enable+0x1c>)
   801a0:	7013      	strb	r3, [r2, #0]
	udi_hid_kbd_protocol = 0;
   801a2:	4a06      	ldr	r2, [pc, #24]	; (801bc <udi_hid_kbd_enable+0x20>)
   801a4:	7013      	strb	r3, [r2, #0]
	udi_hid_kbd_b_report_trans_ongoing = false;
   801a6:	4a06      	ldr	r2, [pc, #24]	; (801c0 <udi_hid_kbd_enable+0x24>)
   801a8:	7013      	strb	r3, [r2, #0]
	memset(udi_hid_kbd_report, 0, UDI_HID_KBD_REPORT_SIZE);
   801aa:	4a06      	ldr	r2, [pc, #24]	; (801c4 <udi_hid_kbd_enable+0x28>)
   801ac:	6013      	str	r3, [r2, #0]
   801ae:	6053      	str	r3, [r2, #4]
	udi_hid_kbd_b_report_valid = false;
   801b0:	4a05      	ldr	r2, [pc, #20]	; (801c8 <udi_hid_kbd_enable+0x2c>)
   801b2:	7013      	strb	r3, [r2, #0]
	return UDI_HID_KBD_ENABLE_EXT();
}
   801b4:	2001      	movs	r0, #1
   801b6:	4770      	bx	lr
   801b8:	20070668 	.word	0x20070668
   801bc:	20070658 	.word	0x20070658
   801c0:	20070655 	.word	0x20070655
   801c4:	20070660 	.word	0x20070660
   801c8:	20070654 	.word	0x20070654

000801cc <udi_hid_kbd_setup>:
	UDI_HID_KBD_DISABLE_EXT();
}


bool udi_hid_kbd_setup(void)
{
   801cc:	b510      	push	{r4, lr}
	return udi_hid_setup(&udi_hid_kbd_rate,
   801ce:	4803      	ldr	r0, [pc, #12]	; (801dc <udi_hid_kbd_setup+0x10>)
   801d0:	4903      	ldr	r1, [pc, #12]	; (801e0 <udi_hid_kbd_setup+0x14>)
   801d2:	4a04      	ldr	r2, [pc, #16]	; (801e4 <udi_hid_kbd_setup+0x18>)
   801d4:	4b04      	ldr	r3, [pc, #16]	; (801e8 <udi_hid_kbd_setup+0x1c>)
   801d6:	4c05      	ldr	r4, [pc, #20]	; (801ec <udi_hid_kbd_setup+0x20>)
   801d8:	47a0      	blx	r4
								&udi_hid_kbd_protocol,
								(uint8_t *) &udi_hid_kbd_report_desc,
								udi_hid_kbd_setreport);
}
   801da:	bd10      	pop	{r4, pc}
   801dc:	20070668 	.word	0x20070668
   801e0:	20070658 	.word	0x20070658
   801e4:	2007012c 	.word	0x2007012c
   801e8:	00080159 	.word	0x00080159
   801ec:	00081a85 	.word	0x00081a85

000801f0 <udc_next_desc_in_iface>:
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
   801f0:	4b0f      	ldr	r3, [pc, #60]	; (80230 <udc_next_desc_in_iface+0x40>)
   801f2:	681b      	ldr	r3, [r3, #0]
   801f4:	681a      	ldr	r2, [r3, #0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   801f6:	8853      	ldrh	r3, [r2, #2]
   801f8:	441a      	add	r2, r3
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   801fa:	7803      	ldrb	r3, [r0, #0]
   801fc:	4418      	add	r0, r3
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
   801fe:	4290      	cmp	r0, r2
   80200:	d210      	bcs.n	80224 <udc_next_desc_in_iface+0x34>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   80202:	7843      	ldrb	r3, [r0, #1]
   80204:	2b04      	cmp	r3, #4
   80206:	d00f      	beq.n	80228 <udc_next_desc_in_iface+0x38>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
   80208:	428b      	cmp	r3, r1
   8020a:	d105      	bne.n	80218 <udc_next_desc_in_iface+0x28>
   8020c:	4770      	bx	lr
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   8020e:	7843      	ldrb	r3, [r0, #1]
   80210:	2b04      	cmp	r3, #4
   80212:	d00b      	beq.n	8022c <udc_next_desc_in_iface+0x3c>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
   80214:	428b      	cmp	r3, r1
   80216:	d00a      	beq.n	8022e <udc_next_desc_in_iface+0x3e>
			return desc; // Specific descriptor found
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   80218:	7803      	ldrb	r3, [r0, #0]
   8021a:	4418      	add	r0, r3
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
   8021c:	4290      	cmp	r0, r2
   8021e:	d3f6      	bcc.n	8020e <udc_next_desc_in_iface+0x1e>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
   80220:	2000      	movs	r0, #0
   80222:	4770      	bx	lr
   80224:	2000      	movs	r0, #0
   80226:	4770      	bx	lr
   80228:	2000      	movs	r0, #0
   8022a:	4770      	bx	lr
   8022c:	2000      	movs	r0, #0
}
   8022e:	4770      	bx	lr
   80230:	2007066c 	.word	0x2007066c

00080234 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
   80234:	b508      	push	{r3, lr}
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
   80236:	4b03      	ldr	r3, [pc, #12]	; (80244 <udc_valid_address+0x10>)
   80238:	7898      	ldrb	r0, [r3, #2]
   8023a:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   8023e:	4b02      	ldr	r3, [pc, #8]	; (80248 <udc_valid_address+0x14>)
   80240:	4798      	blx	r3
   80242:	bd08      	pop	{r3, pc}
   80244:	20070720 	.word	0x20070720
   80248:	00081481 	.word	0x00081481

0008024c <udc_update_iface_desc>:
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
   8024c:	4b16      	ldr	r3, [pc, #88]	; (802a8 <udc_update_iface_desc+0x5c>)
   8024e:	781b      	ldrb	r3, [r3, #0]
   80250:	b30b      	cbz	r3, 80296 <udc_update_iface_desc+0x4a>
		return false;
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   80252:	4b16      	ldr	r3, [pc, #88]	; (802ac <udc_update_iface_desc+0x60>)
   80254:	681b      	ldr	r3, [r3, #0]
   80256:	681b      	ldr	r3, [r3, #0]
   80258:	791a      	ldrb	r2, [r3, #4]
   8025a:	4282      	cmp	r2, r0
   8025c:	d91d      	bls.n	8029a <udc_update_iface_desc+0x4e>
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
   8025e:	b410      	push	{r4}
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
   80260:	4a13      	ldr	r2, [pc, #76]	; (802b0 <udc_update_iface_desc+0x64>)
   80262:	6013      	str	r3, [r2, #0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   80264:	885c      	ldrh	r4, [r3, #2]
   80266:	441c      	add	r4, r3
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
   80268:	42a3      	cmp	r3, r4
   8026a:	d218      	bcs.n	8029e <udc_update_iface_desc+0x52>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
   8026c:	785a      	ldrb	r2, [r3, #1]
   8026e:	2a04      	cmp	r2, #4
   80270:	d109      	bne.n	80286 <udc_update_iface_desc+0x3a>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
   80272:	789a      	ldrb	r2, [r3, #2]
   80274:	4282      	cmp	r2, r0
   80276:	d106      	bne.n	80286 <udc_update_iface_desc+0x3a>
   80278:	78da      	ldrb	r2, [r3, #3]
   8027a:	428a      	cmp	r2, r1
   8027c:	d103      	bne.n	80286 <udc_update_iface_desc+0x3a>
   8027e:	4a0c      	ldr	r2, [pc, #48]	; (802b0 <udc_update_iface_desc+0x64>)
   80280:	6013      	str	r3, [r2, #0]
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
   80282:	2001      	movs	r0, #1
   80284:	e00c      	b.n	802a0 <udc_update_iface_desc+0x54>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
   80286:	781a      	ldrb	r2, [r3, #0]
   80288:	4413      	add	r3, r2
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
   8028a:	42a3      	cmp	r3, r4
   8028c:	d3ee      	bcc.n	8026c <udc_update_iface_desc+0x20>
   8028e:	4a08      	ldr	r2, [pc, #32]	; (802b0 <udc_update_iface_desc+0x64>)
   80290:	6013      	str	r3, [r2, #0]
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
   80292:	2000      	movs	r0, #0
   80294:	e004      	b.n	802a0 <udc_update_iface_desc+0x54>
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
		return false;
   80296:	2000      	movs	r0, #0
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
}
   80298:	4770      	bx	lr
	if (0 == udc_num_configuration) {
		return false;
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
   8029a:	2000      	movs	r0, #0
   8029c:	4770      	bx	lr
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
   8029e:	2000      	movs	r0, #0
}
   802a0:	f85d 4b04 	ldr.w	r4, [sp], #4
   802a4:	4770      	bx	lr
   802a6:	bf00      	nop
   802a8:	20070678 	.word	0x20070678
   802ac:	2007066c 	.word	0x2007066c
   802b0:	2007067c 	.word	0x2007067c

000802b4 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
   802b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   802b8:	4604      	mov	r4, r0
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   802ba:	2100      	movs	r1, #0
   802bc:	4b12      	ldr	r3, [pc, #72]	; (80308 <udc_iface_disable+0x54>)
   802be:	4798      	blx	r3
   802c0:	4680      	mov	r8, r0
   802c2:	b1e8      	cbz	r0, 80300 <udc_iface_disable+0x4c>
		return false;
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   802c4:	4b11      	ldr	r3, [pc, #68]	; (8030c <udc_iface_disable+0x58>)
   802c6:	681b      	ldr	r3, [r3, #0]
   802c8:	685b      	ldr	r3, [r3, #4]
   802ca:	f853 9024 	ldr.w	r9, [r3, r4, lsl #2]

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   802ce:	f8d9 300c 	ldr.w	r3, [r9, #12]
   802d2:	4798      	blx	r3
   802d4:	4601      	mov	r1, r0
   802d6:	4620      	mov	r0, r4
   802d8:	4b0b      	ldr	r3, [pc, #44]	; (80308 <udc_iface_disable+0x54>)
   802da:	4798      	blx	r3
   802dc:	4680      	mov	r8, r0
   802de:	b178      	cbz	r0, 80300 <udc_iface_disable+0x4c>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   802e0:	4b0b      	ldr	r3, [pc, #44]	; (80310 <udc_iface_disable+0x5c>)
   802e2:	681c      	ldr	r4, [r3, #0]
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   802e4:	2605      	movs	r6, #5
   802e6:	4d0b      	ldr	r5, [pc, #44]	; (80314 <udc_iface_disable+0x60>)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
   802e8:	4f0b      	ldr	r7, [pc, #44]	; (80318 <udc_iface_disable+0x64>)
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   802ea:	4620      	mov	r0, r4
   802ec:	4631      	mov	r1, r6
   802ee:	47a8      	blx	r5
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
   802f0:	4604      	mov	r4, r0
   802f2:	b110      	cbz	r0, 802fa <udc_iface_disable+0x46>
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
   802f4:	7880      	ldrb	r0, [r0, #2]
   802f6:	47b8      	blx	r7
		}
   802f8:	e7f7      	b.n	802ea <udc_iface_disable+0x36>
	}
#endif

	// Disable interface
	udi_api->disable();
   802fa:	f8d9 3004 	ldr.w	r3, [r9, #4]
   802fe:	4798      	blx	r3
	return true;
}
   80300:	4640      	mov	r0, r8
   80302:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   80306:	bf00      	nop
   80308:	0008024d 	.word	0x0008024d
   8030c:	2007066c 	.word	0x2007066c
   80310:	2007067c 	.word	0x2007067c
   80314:	000801f1 	.word	0x000801f1
   80318:	000814c5 	.word	0x000814c5

0008031c <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
   8031c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80320:	4680      	mov	r8, r0
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
   80322:	4b10      	ldr	r3, [pc, #64]	; (80364 <udc_iface_enable+0x48>)
   80324:	4798      	blx	r3
   80326:	4603      	mov	r3, r0
   80328:	b1c8      	cbz	r0, 8035e <udc_iface_enable+0x42>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   8032a:	4b0f      	ldr	r3, [pc, #60]	; (80368 <udc_iface_enable+0x4c>)
   8032c:	681c      	ldr	r4, [r3, #0]
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   8032e:	2605      	movs	r6, #5
   80330:	4d0e      	ldr	r5, [pc, #56]	; (8036c <udc_iface_enable+0x50>)
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   80332:	4f0f      	ldr	r7, [pc, #60]	; (80370 <udc_iface_enable+0x54>)

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   80334:	4620      	mov	r0, r4
   80336:	4631      	mov	r1, r6
   80338:	47a8      	blx	r5
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
   8033a:	4604      	mov	r4, r0
   8033c:	b138      	cbz	r0, 8034e <udc_iface_enable+0x32>
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   8033e:	7880      	ldrb	r0, [r0, #2]
   80340:	78e1      	ldrb	r1, [r4, #3]
   80342:	88a2      	ldrh	r2, [r4, #4]
   80344:	47b8      	blx	r7
   80346:	4603      	mov	r3, r0
   80348:	2800      	cmp	r0, #0
   8034a:	d1f3      	bne.n	80334 <udc_iface_enable+0x18>
   8034c:	e007      	b.n	8035e <udc_iface_enable+0x42>
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
   8034e:	4b09      	ldr	r3, [pc, #36]	; (80374 <udc_iface_enable+0x58>)
   80350:	681b      	ldr	r3, [r3, #0]
   80352:	685b      	ldr	r3, [r3, #4]
   80354:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
   80358:	681b      	ldr	r3, [r3, #0]
   8035a:	4798      	blx	r3
   8035c:	4603      	mov	r3, r0
}
   8035e:	4618      	mov	r0, r3
   80360:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   80364:	0008024d 	.word	0x0008024d
   80368:	2007067c 	.word	0x2007067c
   8036c:	000801f1 	.word	0x000801f1
   80370:	000817fd 	.word	0x000817fd
   80374:	2007066c 	.word	0x2007066c

00080378 <udc_get_interface_desc>:
//! @}

usb_iface_desc_t UDC_DESC_STORAGE *udc_get_interface_desc(void)
{
	return udc_ptr_iface;
}
   80378:	4b01      	ldr	r3, [pc, #4]	; (80380 <udc_get_interface_desc+0x8>)
   8037a:	6818      	ldr	r0, [r3, #0]
   8037c:	4770      	bx	lr
   8037e:	bf00      	nop
   80380:	2007067c 	.word	0x2007067c

00080384 <udc_start>:
}

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
   80384:	b508      	push	{r3, lr}
	udd_enable();
   80386:	4b01      	ldr	r3, [pc, #4]	; (8038c <udc_start+0x8>)
   80388:	4798      	blx	r3
   8038a:	bd08      	pop	{r3, pc}
   8038c:	00080ccd 	.word	0x00080ccd

00080390 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
   80390:	b570      	push	{r4, r5, r6, lr}
	uint8_t iface_num;

	if (udc_num_configuration) {
   80392:	4b0d      	ldr	r3, [pc, #52]	; (803c8 <udc_reset+0x38>)
   80394:	781b      	ldrb	r3, [r3, #0]
   80396:	b183      	cbz	r3, 803ba <udc_reset+0x2a>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   80398:	4b0c      	ldr	r3, [pc, #48]	; (803cc <udc_reset+0x3c>)
   8039a:	681b      	ldr	r3, [r3, #0]
   8039c:	681b      	ldr	r3, [r3, #0]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   8039e:	791b      	ldrb	r3, [r3, #4]
   803a0:	b15b      	cbz	r3, 803ba <udc_reset+0x2a>
   803a2:	2400      	movs	r4, #0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
   803a4:	4e0a      	ldr	r6, [pc, #40]	; (803d0 <udc_reset+0x40>)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   803a6:	4d09      	ldr	r5, [pc, #36]	; (803cc <udc_reset+0x3c>)
				iface_num++) {
			udc_iface_disable(iface_num);
   803a8:	4620      	mov	r0, r4
   803aa:	47b0      	blx	r6
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
   803ac:	3401      	adds	r4, #1
   803ae:	b2e4      	uxtb	r4, r4
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   803b0:	682b      	ldr	r3, [r5, #0]
   803b2:	681b      	ldr	r3, [r3, #0]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   803b4:	791b      	ldrb	r3, [r3, #4]
   803b6:	42a3      	cmp	r3, r4
   803b8:	d8f6      	bhi.n	803a8 <udc_reset+0x18>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
   803ba:	2300      	movs	r3, #0
   803bc:	4a02      	ldr	r2, [pc, #8]	; (803c8 <udc_reset+0x38>)
   803be:	7013      	strb	r3, [r2, #0]
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
   803c0:	4a04      	ldr	r2, [pc, #16]	; (803d4 <udc_reset+0x44>)
   803c2:	8013      	strh	r3, [r2, #0]
   803c4:	bd70      	pop	{r4, r5, r6, pc}
   803c6:	bf00      	nop
   803c8:	20070678 	.word	0x20070678
   803cc:	2007066c 	.word	0x2007066c
   803d0:	000802b5 	.word	0x000802b5
   803d4:	20070676 	.word	0x20070676

000803d8 <udc_sof_notify>:
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}

void udc_sof_notify(void)
{
   803d8:	b538      	push	{r3, r4, r5, lr}
	uint8_t iface_num;

	if (udc_num_configuration) {
   803da:	4b0c      	ldr	r3, [pc, #48]	; (8040c <udc_sof_notify+0x34>)
   803dc:	781b      	ldrb	r3, [r3, #0]
   803de:	b19b      	cbz	r3, 80408 <udc_sof_notify+0x30>
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   803e0:	4b0b      	ldr	r3, [pc, #44]	; (80410 <udc_sof_notify+0x38>)
   803e2:	681b      	ldr	r3, [r3, #0]
   803e4:	681a      	ldr	r2, [r3, #0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   803e6:	7912      	ldrb	r2, [r2, #4]
   803e8:	b172      	cbz	r2, 80408 <udc_sof_notify+0x30>
   803ea:	2400      	movs	r4, #0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   803ec:	4d08      	ldr	r5, [pc, #32]	; (80410 <udc_sof_notify+0x38>)
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
   803ee:	685b      	ldr	r3, [r3, #4]
   803f0:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   803f4:	691b      	ldr	r3, [r3, #16]
   803f6:	b103      	cbz	r3, 803fa <udc_sof_notify+0x22>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
   803f8:	4798      	blx	r3
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
   803fa:	3401      	adds	r4, #1
   803fc:	b2e4      	uxtb	r4, r4
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   803fe:	682b      	ldr	r3, [r5, #0]
   80400:	681a      	ldr	r2, [r3, #0]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
   80402:	7912      	ldrb	r2, [r2, #4]
   80404:	42a2      	cmp	r2, r4
   80406:	d8f2      	bhi.n	803ee <udc_sof_notify+0x16>
   80408:	bd38      	pop	{r3, r4, r5, pc}
   8040a:	bf00      	nop
   8040c:	20070678 	.word	0x20070678
   80410:	2007066c 	.word	0x2007066c

00080414 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
   80414:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
   80416:	4b81      	ldr	r3, [pc, #516]	; (8061c <udc_process_setup+0x208>)
   80418:	2200      	movs	r2, #0
   8041a:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
   8041c:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   8041e:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
   80420:	781b      	ldrb	r3, [r3, #0]
   80422:	f013 0f80 	tst.w	r3, #128	; 0x80
   80426:	f000 81f0 	beq.w	8080a <udc_process_setup+0x3f6>
		if (udd_g_ctrlreq.req.wLength == 0) {
   8042a:	4a7c      	ldr	r2, [pc, #496]	; (8061c <udc_process_setup+0x208>)
   8042c:	88d2      	ldrh	r2, [r2, #6]
   8042e:	2a00      	cmp	r2, #0
   80430:	f040 81e7 	bne.w	80802 <udc_process_setup+0x3ee>
   80434:	e1e1      	b.n	807fa <udc_process_setup+0x3e6>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error for USB host
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   80436:	f013 031f 	ands.w	r3, r3, #31
   8043a:	f040 8082 	bne.w	80542 <udc_process_setup+0x12e>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   8043e:	4977      	ldr	r1, [pc, #476]	; (8061c <udc_process_setup+0x208>)
   80440:	7849      	ldrb	r1, [r1, #1]
   80442:	2906      	cmp	r1, #6
   80444:	d00b      	beq.n	8045e <udc_process_setup+0x4a>
   80446:	2908      	cmp	r1, #8
   80448:	d073      	beq.n	80532 <udc_process_setup+0x11e>
   8044a:	2900      	cmp	r1, #0
   8044c:	d179      	bne.n	80542 <udc_process_setup+0x12e>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
   8044e:	2a02      	cmp	r2, #2
   80450:	f040 8183 	bne.w	8075a <udc_process_setup+0x346>
		return false;
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
   80454:	4872      	ldr	r0, [pc, #456]	; (80620 <udc_process_setup+0x20c>)
   80456:	2102      	movs	r1, #2
   80458:	4b72      	ldr	r3, [pc, #456]	; (80624 <udc_process_setup+0x210>)
   8045a:	4798      	blx	r3
   8045c:	e1dc      	b.n	80818 <udc_process_setup+0x404>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
   8045e:	4b6f      	ldr	r3, [pc, #444]	; (8061c <udc_process_setup+0x208>)
   80460:	885a      	ldrh	r2, [r3, #2]

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
   80462:	0a13      	lsrs	r3, r2, #8
   80464:	3b01      	subs	r3, #1
   80466:	2b0e      	cmp	r3, #14
   80468:	f200 816e 	bhi.w	80748 <udc_process_setup+0x334>
   8046c:	e8df f013 	tbh	[pc, r3, lsl #1]
   80470:	0016000f 	.word	0x0016000f
   80474:	016c0034 	.word	0x016c0034
   80478:	016c016c 	.word	0x016c016c
   8047c:	016c016c 	.word	0x016c016c
   80480:	016c016c 	.word	0x016c016c
   80484:	016c016c 	.word	0x016c016c
   80488:	016c016c 	.word	0x016c016c
   8048c:	002a      	.short	0x002a
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
   8048e:	4b66      	ldr	r3, [pc, #408]	; (80628 <udc_process_setup+0x214>)
   80490:	681b      	ldr	r3, [r3, #0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
   80492:	4618      	mov	r0, r3
   80494:	7819      	ldrb	r1, [r3, #0]
   80496:	4b63      	ldr	r3, [pc, #396]	; (80624 <udc_process_setup+0x210>)
   80498:	4798      	blx	r3
   8049a:	e041      	b.n	80520 <udc_process_setup+0x10c>
 */
static bool udc_req_std_dev_get_descriptor(void)
{
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
   8049c:	b2d2      	uxtb	r2, r2
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
   8049e:	4b62      	ldr	r3, [pc, #392]	; (80628 <udc_process_setup+0x214>)
   804a0:	681b      	ldr	r3, [r3, #0]
   804a2:	7c5b      	ldrb	r3, [r3, #17]
   804a4:	4293      	cmp	r3, r2
   804a6:	f240 8158 	bls.w	8075a <udc_process_setup+0x346>
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
   804aa:	4b5f      	ldr	r3, [pc, #380]	; (80628 <udc_process_setup+0x214>)
   804ac:	685b      	ldr	r3, [r3, #4]
   804ae:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
   804b2:	4618      	mov	r0, r3
   804b4:	8859      	ldrh	r1, [r3, #2]
   804b6:	4b5b      	ldr	r3, [pc, #364]	; (80624 <udc_process_setup+0x210>)
   804b8:	4798      	blx	r3
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   804ba:	4b58      	ldr	r3, [pc, #352]	; (8061c <udc_process_setup+0x208>)
   804bc:	689b      	ldr	r3, [r3, #8]
   804be:	2202      	movs	r2, #2
   804c0:	705a      	strb	r2, [r3, #1]
   804c2:	e02d      	b.n	80520 <udc_process_setup+0x10c>
		break;
#endif

	case USB_DT_BOS:
		// Device BOS descriptor requested
		if (udc_config.conf_bos == NULL) {
   804c4:	4b58      	ldr	r3, [pc, #352]	; (80628 <udc_process_setup+0x214>)
   804c6:	689b      	ldr	r3, [r3, #8]
   804c8:	2b00      	cmp	r3, #0
   804ca:	f000 8146 	beq.w	8075a <udc_process_setup+0x346>
			return false;
		}
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
   804ce:	4618      	mov	r0, r3
   804d0:	8859      	ldrh	r1, [r3, #2]
   804d2:	4b54      	ldr	r3, [pc, #336]	; (80624 <udc_process_setup+0x210>)
   804d4:	4798      	blx	r3
   804d6:	e023      	b.n	80520 <udc_process_setup+0x10c>
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
   804d8:	b2d2      	uxtb	r2, r2
   804da:	2a03      	cmp	r2, #3
   804dc:	f200 813d 	bhi.w	8075a <udc_process_setup+0x346>
   804e0:	e8df f012 	tbh	[pc, r2, lsl #1]
   804e4:	000c0007 	.word	0x000c0007
   804e8:	00040197 	.word	0x00040197
		str = udc_string_product_name;
		break;
#endif
#if defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER
	case 3:
		str_length = USB_DEVICE_SERIAL_NAME_SIZE;
   804ec:	2104      	movs	r1, #4
		str = udc_get_string_serial_name();
   804ee:	4b4f      	ldr	r3, [pc, #316]	; (8062c <udc_process_setup+0x218>)
   804f0:	e006      	b.n	80500 <udc_process_setup+0xec>
	uint8_t str_length = 0;

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
   804f2:	484f      	ldr	r0, [pc, #316]	; (80630 <udc_process_setup+0x21c>)
   804f4:	2104      	movs	r1, #4
   804f6:	4b4b      	ldr	r3, [pc, #300]	; (80624 <udc_process_setup+0x210>)
   804f8:	4798      	blx	r3
   804fa:	e011      	b.n	80520 <udc_process_setup+0x10c>
		break;

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
		str = udc_string_manufacturer_name;
   804fc:	4b4d      	ldr	r3, [pc, #308]	; (80634 <udc_process_setup+0x220>)
				sizeof(udc_string_desc_languageid));
		break;

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
   804fe:	210c      	movs	r1, #12
   80500:	461c      	mov	r4, r3
   80502:	484d      	ldr	r0, [pc, #308]	; (80638 <udc_process_setup+0x224>)
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
   80504:	f813 2b01 	ldrb.w	r2, [r3], #1
   80508:	f820 2f02 	strh.w	r2, [r0, #2]!
   8050c:	1b1a      	subs	r2, r3, r4
#endif
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
   8050e:	b2d2      	uxtb	r2, r2
   80510:	428a      	cmp	r2, r1
   80512:	d3f7      	bcc.n	80504 <udc_process_setup+0xf0>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
   80514:	0049      	lsls	r1, r1, #1
   80516:	3102      	adds	r1, #2
   80518:	4847      	ldr	r0, [pc, #284]	; (80638 <udc_process_setup+0x224>)
   8051a:	7001      	strb	r1, [r0, #0]
		udd_set_setup_payload(
   8051c:	4b41      	ldr	r3, [pc, #260]	; (80624 <udc_process_setup+0x210>)
   8051e:	4798      	blx	r3
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
   80520:	4b3e      	ldr	r3, [pc, #248]	; (8061c <udc_process_setup+0x208>)
   80522:	88da      	ldrh	r2, [r3, #6]
   80524:	899b      	ldrh	r3, [r3, #12]
   80526:	4293      	cmp	r3, r2
   80528:	f240 8176 	bls.w	80818 <udc_process_setup+0x404>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
   8052c:	4b3b      	ldr	r3, [pc, #236]	; (8061c <udc_process_setup+0x208>)
   8052e:	819a      	strh	r2, [r3, #12]
   80530:	e172      	b.n	80818 <udc_process_setup+0x404>
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
	if (udd_g_ctrlreq.req.wLength != 1) {
   80532:	2a01      	cmp	r2, #1
   80534:	f040 8111 	bne.w	8075a <udc_process_setup+0x346>
		return false;
	}

	udd_set_setup_payload(&udc_num_configuration,1);
   80538:	4840      	ldr	r0, [pc, #256]	; (8063c <udc_process_setup+0x228>)
   8053a:	2101      	movs	r1, #1
   8053c:	4b39      	ldr	r3, [pc, #228]	; (80624 <udc_process_setup+0x210>)
   8053e:	4798      	blx	r3
   80540:	e16a      	b.n	80818 <udc_process_setup+0x404>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   80542:	2b01      	cmp	r3, #1
   80544:	d127      	bne.n	80596 <udc_process_setup+0x182>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   80546:	4935      	ldr	r1, [pc, #212]	; (8061c <udc_process_setup+0x208>)
   80548:	7849      	ldrb	r1, [r1, #1]
   8054a:	290a      	cmp	r1, #10
   8054c:	d123      	bne.n	80596 <udc_process_setup+0x182>
static bool udc_req_std_iface_get_setting(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
   8054e:	2a01      	cmp	r2, #1
   80550:	f040 8103 	bne.w	8075a <udc_process_setup+0x346>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   80554:	4b39      	ldr	r3, [pc, #228]	; (8063c <udc_process_setup+0x228>)
   80556:	781b      	ldrb	r3, [r3, #0]
   80558:	2b00      	cmp	r3, #0
   8055a:	f000 80fe 	beq.w	8075a <udc_process_setup+0x346>
		return false; // The device is not is configured state yet
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   8055e:	4b2f      	ldr	r3, [pc, #188]	; (8061c <udc_process_setup+0x208>)
   80560:	791c      	ldrb	r4, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   80562:	4b37      	ldr	r3, [pc, #220]	; (80640 <udc_process_setup+0x22c>)
   80564:	681d      	ldr	r5, [r3, #0]
   80566:	682b      	ldr	r3, [r5, #0]
   80568:	791b      	ldrb	r3, [r3, #4]
   8056a:	42a3      	cmp	r3, r4
   8056c:	f240 80f5 	bls.w	8075a <udc_process_setup+0x346>
		return false;
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   80570:	4620      	mov	r0, r4
   80572:	2100      	movs	r1, #0
   80574:	4b33      	ldr	r3, [pc, #204]	; (80644 <udc_process_setup+0x230>)
   80576:	4798      	blx	r3
   80578:	2800      	cmp	r0, #0
   8057a:	f000 80ee 	beq.w	8075a <udc_process_setup+0x346>
		return false;
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   8057e:	686b      	ldr	r3, [r5, #4]
	udc_iface_setting = udi_api->getsetting();
   80580:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   80584:	68db      	ldr	r3, [r3, #12]
   80586:	4798      	blx	r3
   80588:	4b2f      	ldr	r3, [pc, #188]	; (80648 <udc_process_setup+0x234>)
   8058a:	7018      	strb	r0, [r3, #0]

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
   8058c:	4618      	mov	r0, r3
   8058e:	2101      	movs	r1, #1
   80590:	4b24      	ldr	r3, [pc, #144]	; (80624 <udc_process_setup+0x210>)
   80592:	4798      	blx	r3
   80594:	e140      	b.n	80818 <udc_process_setup+0x404>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   80596:	2b02      	cmp	r3, #2
   80598:	f040 80df 	bne.w	8075a <udc_process_setup+0x346>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
   8059c:	4b1f      	ldr	r3, [pc, #124]	; (8061c <udc_process_setup+0x208>)
   8059e:	785b      	ldrb	r3, [r3, #1]
   805a0:	2b00      	cmp	r3, #0
   805a2:	f040 80d3 	bne.w	8074c <udc_process_setup+0x338>
 */
static bool udc_req_std_ep_get_status(void)
{
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
   805a6:	2a02      	cmp	r2, #2
   805a8:	f040 80d7 	bne.w	8075a <udc_process_setup+0x346>
		return false;
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
   805ac:	4b1b      	ldr	r3, [pc, #108]	; (8061c <udc_process_setup+0x208>)
   805ae:	7918      	ldrb	r0, [r3, #4]
   805b0:	4b26      	ldr	r3, [pc, #152]	; (8064c <udc_process_setup+0x238>)
   805b2:	4798      	blx	r3
   805b4:	4b26      	ldr	r3, [pc, #152]	; (80650 <udc_process_setup+0x23c>)
   805b6:	8018      	strh	r0, [r3, #0]
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
   805b8:	4618      	mov	r0, r3
   805ba:	2102      	movs	r1, #2
   805bc:	4b19      	ldr	r3, [pc, #100]	; (80624 <udc_process_setup+0x210>)
   805be:	4798      	blx	r3
   805c0:	e12a      	b.n	80818 <udc_process_setup+0x404>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   805c2:	f013 031f 	ands.w	r3, r3, #31
   805c6:	d17f      	bne.n	806c8 <udc_process_setup+0x2b4>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
   805c8:	4a14      	ldr	r2, [pc, #80]	; (8061c <udc_process_setup+0x208>)
   805ca:	7852      	ldrb	r2, [r2, #1]
   805cc:	3a01      	subs	r2, #1
   805ce:	2a08      	cmp	r2, #8
   805d0:	d87a      	bhi.n	806c8 <udc_process_setup+0x2b4>
   805d2:	e8df f012 	tbh	[pc, r2, lsl #1]
   805d6:	0012      	.short	0x0012
   805d8:	00bd0079 	.word	0x00bd0079
   805dc:	00090079 	.word	0x00090079
   805e0:	00790079 	.word	0x00790079
   805e4:	00410079 	.word	0x00410079
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   805e8:	4b0c      	ldr	r3, [pc, #48]	; (8061c <udc_process_setup+0x208>)
   805ea:	88db      	ldrh	r3, [r3, #6]
   805ec:	2b00      	cmp	r3, #0
   805ee:	f040 80b4 	bne.w	8075a <udc_process_setup+0x346>
		return false;
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
   805f2:	4a18      	ldr	r2, [pc, #96]	; (80654 <udc_process_setup+0x240>)
   805f4:	4b09      	ldr	r3, [pc, #36]	; (8061c <udc_process_setup+0x208>)
   805f6:	611a      	str	r2, [r3, #16]
   805f8:	e10e      	b.n	80818 <udc_process_setup+0x404>
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   805fa:	4b08      	ldr	r3, [pc, #32]	; (8061c <udc_process_setup+0x208>)
   805fc:	88db      	ldrh	r3, [r3, #6]
   805fe:	2b00      	cmp	r3, #0
   80600:	f040 80ab 	bne.w	8075a <udc_process_setup+0x346>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
   80604:	4b05      	ldr	r3, [pc, #20]	; (8061c <udc_process_setup+0x208>)
   80606:	885b      	ldrh	r3, [r3, #2]
   80608:	2b01      	cmp	r3, #1
   8060a:	f040 80a6 	bne.w	8075a <udc_process_setup+0x346>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
   8060e:	4a04      	ldr	r2, [pc, #16]	; (80620 <udc_process_setup+0x20c>)
   80610:	8813      	ldrh	r3, [r2, #0]
   80612:	f023 0302 	bic.w	r3, r3, #2
   80616:	8013      	strh	r3, [r2, #0]
   80618:	e0fe      	b.n	80818 <udc_process_setup+0x404>
   8061a:	bf00      	nop
   8061c:	20070720 	.word	0x20070720
   80620:	20070676 	.word	0x20070676
   80624:	000814b9 	.word	0x000814b9
   80628:	200701e4 	.word	0x200701e4
   8062c:	0008241c 	.word	0x0008241c
   80630:	200701b4 	.word	0x200701b4
   80634:	20070188 	.word	0x20070188
   80638:	20070198 	.word	0x20070198
   8063c:	20070678 	.word	0x20070678
   80640:	2007066c 	.word	0x2007066c
   80644:	0008024d 	.word	0x0008024d
   80648:	20070674 	.word	0x20070674
   8064c:	00081521 	.word	0x00081521
   80650:	20070670 	.word	0x20070670
   80654:	00080235 	.word	0x00080235
static bool udc_req_std_dev_set_configuration(void)
{
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
   80658:	4b71      	ldr	r3, [pc, #452]	; (80820 <udc_process_setup+0x40c>)
   8065a:	88db      	ldrh	r3, [r3, #6]
   8065c:	2b00      	cmp	r3, #0
   8065e:	d17c      	bne.n	8075a <udc_process_setup+0x346>
		return false;
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
   80660:	4b70      	ldr	r3, [pc, #448]	; (80824 <udc_process_setup+0x410>)
   80662:	4798      	blx	r3
   80664:	2800      	cmp	r0, #0
   80666:	d078      	beq.n	8075a <udc_process_setup+0x346>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   80668:	4b6d      	ldr	r3, [pc, #436]	; (80820 <udc_process_setup+0x40c>)
   8066a:	789a      	ldrb	r2, [r3, #2]
				udc_config.confdev_lsfs->bNumConfigurations) {
   8066c:	4b6e      	ldr	r3, [pc, #440]	; (80828 <udc_process_setup+0x414>)
   8066e:	681b      	ldr	r3, [r3, #0]
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   80670:	7c5b      	ldrb	r3, [r3, #17]
   80672:	429a      	cmp	r2, r3
   80674:	dc71      	bgt.n	8075a <udc_process_setup+0x346>
			return false;
		}
	}

	// Reset current configuration
	udc_reset();
   80676:	4b6d      	ldr	r3, [pc, #436]	; (8082c <udc_process_setup+0x418>)
   80678:	4798      	blx	r3

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
   8067a:	4b69      	ldr	r3, [pc, #420]	; (80820 <udc_process_setup+0x40c>)
   8067c:	789b      	ldrb	r3, [r3, #2]
   8067e:	4a6c      	ldr	r2, [pc, #432]	; (80830 <udc_process_setup+0x41c>)
   80680:	7013      	strb	r3, [r2, #0]
	if (udc_num_configuration == 0) {
   80682:	2b00      	cmp	r3, #0
   80684:	f000 80c8 	beq.w	80818 <udc_process_setup+0x404>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
   80688:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   8068c:	3b01      	subs	r3, #1
   8068e:	4a66      	ldr	r2, [pc, #408]	; (80828 <udc_process_setup+0x414>)
   80690:	6852      	ldr	r2, [r2, #4]
   80692:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
   80696:	4967      	ldr	r1, [pc, #412]	; (80834 <udc_process_setup+0x420>)
   80698:	6008      	str	r0, [r1, #0]
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   8069a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
   8069e:	791b      	ldrb	r3, [r3, #4]
   806a0:	2b00      	cmp	r3, #0
   806a2:	f000 80b9 	beq.w	80818 <udc_process_setup+0x404>
   806a6:	2400      	movs	r4, #0
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
   806a8:	4626      	mov	r6, r4
   806aa:	4d63      	ldr	r5, [pc, #396]	; (80838 <udc_process_setup+0x424>)
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   806ac:	460f      	mov	r7, r1
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
   806ae:	4620      	mov	r0, r4
   806b0:	4631      	mov	r1, r6
   806b2:	47a8      	blx	r5
   806b4:	2800      	cmp	r0, #0
   806b6:	d050      	beq.n	8075a <udc_process_setup+0x346>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   806b8:	3401      	adds	r4, #1
   806ba:	b2e4      	uxtb	r4, r4
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   806bc:	683b      	ldr	r3, [r7, #0]
   806be:	681b      	ldr	r3, [r3, #0]
   806c0:	791b      	ldrb	r3, [r3, #4]
   806c2:	42a3      	cmp	r3, r4
   806c4:	d8f3      	bhi.n	806ae <udc_process_setup+0x29a>
   806c6:	e0a7      	b.n	80818 <udc_process_setup+0x404>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   806c8:	2b01      	cmp	r3, #1
   806ca:	d119      	bne.n	80700 <udc_process_setup+0x2ec>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
   806cc:	4a54      	ldr	r2, [pc, #336]	; (80820 <udc_process_setup+0x40c>)
   806ce:	7852      	ldrb	r2, [r2, #1]
   806d0:	2a0b      	cmp	r2, #11
   806d2:	d115      	bne.n	80700 <udc_process_setup+0x2ec>
 */
static bool udc_req_std_iface_set_setting(void)
{
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
   806d4:	4b52      	ldr	r3, [pc, #328]	; (80820 <udc_process_setup+0x40c>)
   806d6:	88db      	ldrh	r3, [r3, #6]
   806d8:	2b00      	cmp	r3, #0
   806da:	d13e      	bne.n	8075a <udc_process_setup+0x346>
		return false; // Error in request
	}
	if (!udc_num_configuration) {
   806dc:	4b54      	ldr	r3, [pc, #336]	; (80830 <udc_process_setup+0x41c>)
   806de:	781b      	ldrb	r3, [r3, #0]
   806e0:	2b00      	cmp	r3, #0
   806e2:	d03a      	beq.n	8075a <udc_process_setup+0x346>
		return false; // The device is not is configured state yet
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   806e4:	4b4e      	ldr	r3, [pc, #312]	; (80820 <udc_process_setup+0x40c>)
   806e6:	791c      	ldrb	r4, [r3, #4]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
   806e8:	885d      	ldrh	r5, [r3, #2]

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
   806ea:	4620      	mov	r0, r4
   806ec:	4b53      	ldr	r3, [pc, #332]	; (8083c <udc_process_setup+0x428>)
   806ee:	4798      	blx	r3
   806f0:	2800      	cmp	r0, #0
   806f2:	d032      	beq.n	8075a <udc_process_setup+0x346>
		return false;
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
   806f4:	4620      	mov	r0, r4
   806f6:	b2e9      	uxtb	r1, r5
   806f8:	4b4f      	ldr	r3, [pc, #316]	; (80838 <udc_process_setup+0x424>)
   806fa:	4798      	blx	r3
   806fc:	4603      	mov	r3, r0
   806fe:	e02a      	b.n	80756 <udc_process_setup+0x342>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   80700:	2b02      	cmp	r3, #2
   80702:	d12a      	bne.n	8075a <udc_process_setup+0x346>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
   80704:	4b46      	ldr	r3, [pc, #280]	; (80820 <udc_process_setup+0x40c>)
   80706:	785b      	ldrb	r3, [r3, #1]
   80708:	2b01      	cmp	r3, #1
   8070a:	d002      	beq.n	80712 <udc_process_setup+0x2fe>
   8070c:	2b03      	cmp	r3, #3
   8070e:	d00c      	beq.n	8072a <udc_process_setup+0x316>
   80710:	e020      	b.n	80754 <udc_process_setup+0x340>
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   80712:	4b43      	ldr	r3, [pc, #268]	; (80820 <udc_process_setup+0x40c>)
   80714:	88db      	ldrh	r3, [r3, #6]
   80716:	bb03      	cbnz	r3, 8075a <udc_process_setup+0x346>
		return false;
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   80718:	4b41      	ldr	r3, [pc, #260]	; (80820 <udc_process_setup+0x40c>)
   8071a:	885b      	ldrh	r3, [r3, #2]
   8071c:	b9eb      	cbnz	r3, 8075a <udc_process_setup+0x346>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   8071e:	4b40      	ldr	r3, [pc, #256]	; (80820 <udc_process_setup+0x40c>)
   80720:	7918      	ldrb	r0, [r3, #4]
   80722:	4b47      	ldr	r3, [pc, #284]	; (80840 <udc_process_setup+0x42c>)
   80724:	4798      	blx	r3
   80726:	4603      	mov	r3, r0
   80728:	e015      	b.n	80756 <udc_process_setup+0x342>
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
	if (udd_g_ctrlreq.req.wLength) {
   8072a:	4b3d      	ldr	r3, [pc, #244]	; (80820 <udc_process_setup+0x40c>)
   8072c:	88db      	ldrh	r3, [r3, #6]
   8072e:	b9a3      	cbnz	r3, 8075a <udc_process_setup+0x346>
		return false;
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   80730:	4b3b      	ldr	r3, [pc, #236]	; (80820 <udc_process_setup+0x40c>)
   80732:	885b      	ldrh	r3, [r3, #2]
   80734:	b98b      	cbnz	r3, 8075a <udc_process_setup+0x346>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
   80736:	4c3a      	ldr	r4, [pc, #232]	; (80820 <udc_process_setup+0x40c>)
   80738:	7920      	ldrb	r0, [r4, #4]
   8073a:	4b42      	ldr	r3, [pc, #264]	; (80844 <udc_process_setup+0x430>)
   8073c:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   8073e:	7920      	ldrb	r0, [r4, #4]
   80740:	4b41      	ldr	r3, [pc, #260]	; (80848 <udc_process_setup+0x434>)
   80742:	4798      	blx	r3
   80744:	4603      	mov	r3, r0
   80746:	e006      	b.n	80756 <udc_process_setup+0x342>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
   80748:	2300      	movs	r3, #0
   8074a:	e004      	b.n	80756 <udc_process_setup+0x342>
				break;
			}
		}
#endif
	}
	return false;
   8074c:	2300      	movs	r3, #0
   8074e:	e002      	b.n	80756 <udc_process_setup+0x342>
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
   80750:	2300      	movs	r3, #0
   80752:	e000      	b.n	80756 <udc_process_setup+0x342>
				break;
			}
		}
#endif
	}
	return false;
   80754:	2300      	movs	r3, #0
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd()) {
   80756:	2b00      	cmp	r3, #0
   80758:	d15f      	bne.n	8081a <udc_process_setup+0x406>
			return true;
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
   8075a:	4b31      	ldr	r3, [pc, #196]	; (80820 <udc_process_setup+0x40c>)
   8075c:	781b      	ldrb	r3, [r3, #0]
   8075e:	f003 031f 	and.w	r3, r3, #31
   80762:	2b01      	cmp	r3, #1
   80764:	d11e      	bne.n	807a4 <udc_process_setup+0x390>
static bool udc_req_iface(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   80766:	4b32      	ldr	r3, [pc, #200]	; (80830 <udc_process_setup+0x41c>)
   80768:	781b      	ldrb	r3, [r3, #0]
   8076a:	b1db      	cbz	r3, 807a4 <udc_process_setup+0x390>
		return false; // The device is not is configured state yet
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   8076c:	4b2c      	ldr	r3, [pc, #176]	; (80820 <udc_process_setup+0x40c>)
   8076e:	791c      	ldrb	r4, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   80770:	4b30      	ldr	r3, [pc, #192]	; (80834 <udc_process_setup+0x420>)
   80772:	681d      	ldr	r5, [r3, #0]
   80774:	682b      	ldr	r3, [r5, #0]
   80776:	791b      	ldrb	r3, [r3, #4]
   80778:	42a3      	cmp	r3, r4
   8077a:	d913      	bls.n	807a4 <udc_process_setup+0x390>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
   8077c:	4620      	mov	r0, r4
   8077e:	2100      	movs	r1, #0
   80780:	4b32      	ldr	r3, [pc, #200]	; (8084c <udc_process_setup+0x438>)
   80782:	4798      	blx	r3
   80784:	b170      	cbz	r0, 807a4 <udc_process_setup+0x390>
		return false;
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   80786:	686b      	ldr	r3, [r5, #4]
   80788:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   8078c:	68eb      	ldr	r3, [r5, #12]
   8078e:	4798      	blx	r3
   80790:	4601      	mov	r1, r0
   80792:	4620      	mov	r0, r4
   80794:	4b2d      	ldr	r3, [pc, #180]	; (8084c <udc_process_setup+0x438>)
   80796:	4798      	blx	r3
   80798:	b120      	cbz	r0, 807a4 <udc_process_setup+0x390>
		return false;
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
   8079a:	68ab      	ldr	r3, [r5, #8]
   8079c:	4798      	blx	r3
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
		if (udc_req_iface()) {
   8079e:	4603      	mov	r3, r0
   807a0:	2800      	cmp	r0, #0
   807a2:	d13a      	bne.n	8081a <udc_process_setup+0x406>
			return true;
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
   807a4:	4b1e      	ldr	r3, [pc, #120]	; (80820 <udc_process_setup+0x40c>)
   807a6:	781b      	ldrb	r3, [r3, #0]
   807a8:	f003 031f 	and.w	r3, r3, #31
   807ac:	2b02      	cmp	r3, #2
   807ae:	d126      	bne.n	807fe <udc_process_setup+0x3ea>
static bool udc_req_ep(void)
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
   807b0:	4b1f      	ldr	r3, [pc, #124]	; (80830 <udc_process_setup+0x41c>)
   807b2:	781b      	ldrb	r3, [r3, #0]
   807b4:	b1eb      	cbz	r3, 807f2 <udc_process_setup+0x3de>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   807b6:	4b1f      	ldr	r3, [pc, #124]	; (80834 <udc_process_setup+0x420>)
   807b8:	681a      	ldr	r2, [r3, #0]
   807ba:	6813      	ldr	r3, [r2, #0]
   807bc:	791b      	ldrb	r3, [r3, #4]
   807be:	b1d3      	cbz	r3, 807f6 <udc_process_setup+0x3e2>
   807c0:	2400      	movs	r4, #0
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   807c2:	4e22      	ldr	r6, [pc, #136]	; (8084c <udc_process_setup+0x438>)
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   807c4:	4f1b      	ldr	r7, [pc, #108]	; (80834 <udc_process_setup+0x420>)
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
   807c6:	6853      	ldr	r3, [r2, #4]
   807c8:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   807cc:	68eb      	ldr	r3, [r5, #12]
   807ce:	4798      	blx	r3
   807d0:	4601      	mov	r1, r0
   807d2:	4620      	mov	r0, r4
   807d4:	47b0      	blx	r6
   807d6:	4603      	mov	r3, r0
   807d8:	b1f8      	cbz	r0, 8081a <udc_process_setup+0x406>
			return false;
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
   807da:	68ab      	ldr	r3, [r5, #8]
   807dc:	4798      	blx	r3
   807de:	4603      	mov	r3, r0
   807e0:	b9d8      	cbnz	r0, 8081a <udc_process_setup+0x406>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
   807e2:	3401      	adds	r4, #1
   807e4:	b2e4      	uxtb	r4, r4
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   807e6:	683a      	ldr	r2, [r7, #0]
   807e8:	6811      	ldr	r1, [r2, #0]
   807ea:	7909      	ldrb	r1, [r1, #4]
   807ec:	42a1      	cmp	r1, r4
   807ee:	d8ea      	bhi.n	807c6 <udc_process_setup+0x3b2>
   807f0:	e013      	b.n	8081a <udc_process_setup+0x406>
{
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
   807f2:	2300      	movs	r3, #0
   807f4:	e011      	b.n	8081a <udc_process_setup+0x406>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
   807f6:	2300      	movs	r3, #0
   807f8:	e00f      	b.n	8081a <udc_process_setup+0x406>
	udd_g_ctrlreq.callback = NULL;
	udd_g_ctrlreq.over_under_run = NULL;

	if (Udd_setup_is_in()) {
		if (udd_g_ctrlreq.req.wLength == 0) {
			return false; // Error from USB host
   807fa:	2300      	movs	r3, #0
   807fc:	e00d      	b.n	8081a <udc_process_setup+0x406>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
   807fe:	2300      	movs	r3, #0
   80800:	e00b      	b.n	8081a <udc_process_setup+0x406>
			return false; // Error from USB host
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   80802:	f013 0f60 	tst.w	r3, #96	; 0x60
   80806:	d1a8      	bne.n	8075a <udc_process_setup+0x346>
   80808:	e615      	b.n	80436 <udc_process_setup+0x22>
   8080a:	f013 0f60 	tst.w	r3, #96	; 0x60
   8080e:	d1a4      	bne.n	8075a <udc_process_setup+0x346>
   80810:	e6d7      	b.n	805c2 <udc_process_setup+0x1ae>
		str = udc_string_manufacturer_name;
		break;
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
   80812:	2109      	movs	r1, #9
		str = udc_string_product_name;
   80814:	4b0e      	ldr	r3, [pc, #56]	; (80850 <udc_process_setup+0x43c>)
   80816:	e673      	b.n	80500 <udc_process_setup+0xec>
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
		if (udc_reqstd()) {
			return true;
   80818:	2301      	movs	r3, #1
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
#endif
}
   8081a:	4618      	mov	r0, r3
   8081c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8081e:	bf00      	nop
   80820:	20070720 	.word	0x20070720
   80824:	000814a9 	.word	0x000814a9
   80828:	200701e4 	.word	0x200701e4
   8082c:	00080391 	.word	0x00080391
   80830:	20070678 	.word	0x20070678
   80834:	2007066c 	.word	0x2007066c
   80838:	0008031d 	.word	0x0008031d
   8083c:	000802b5 	.word	0x000802b5
   80840:	00081629 	.word	0x00081629
   80844:	00081a09 	.word	0x00081a09
   80848:	00081535 	.word	0x00081535
   8084c:	0008024d 	.word	0x0008024d
   80850:	2007017c 	.word	0x2007017c

00080854 <udd_ctrl_init>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80854:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80858:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
   8085a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8085e:	2100      	movs	r1, #0
   80860:	4a0a      	ldr	r2, [pc, #40]	; (8088c <udd_ctrl_init+0x38>)
   80862:	7011      	strb	r1, [r2, #0]
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
   80864:	2101      	movs	r1, #1
   80866:	4a0a      	ldr	r2, [pc, #40]	; (80890 <udd_ctrl_init+0x3c>)
   80868:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8086a:	b923      	cbnz	r3, 80876 <udd_ctrl_init+0x22>
		cpu_irq_enable();
   8086c:	4b07      	ldr	r3, [pc, #28]	; (8088c <udd_ctrl_init+0x38>)
   8086e:	7019      	strb	r1, [r3, #0]
   80870:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80874:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
   80876:	2202      	movs	r2, #2
   80878:	4b06      	ldr	r3, [pc, #24]	; (80894 <udd_ctrl_init+0x40>)
   8087a:	601a      	str	r2, [r3, #0]

	udd_g_ctrlreq.callback = NULL;
   8087c:	4a06      	ldr	r2, [pc, #24]	; (80898 <udd_ctrl_init+0x44>)
   8087e:	2300      	movs	r3, #0
   80880:	6113      	str	r3, [r2, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   80882:	6153      	str	r3, [r2, #20]
	udd_g_ctrlreq.payload_size = 0;
   80884:	8193      	strh	r3, [r2, #12]
	udd_ep_control_state = UDD_EPCTRL_SETUP;
   80886:	4a05      	ldr	r2, [pc, #20]	; (8089c <udd_ctrl_init+0x48>)
   80888:	7013      	strb	r3, [r2, #0]
   8088a:	4770      	bx	lr
   8088c:	20070206 	.word	0x20070206
   80890:	400ac220 	.word	0x400ac220
   80894:	400ac160 	.word	0x400ac160
   80898:	20070720 	.word	0x20070720
   8089c:	2007069d 	.word	0x2007069d

000808a0 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
   808a0:	2205      	movs	r2, #5
   808a2:	4b03      	ldr	r3, [pc, #12]	; (808b0 <udd_ctrl_stall_data+0x10>)
   808a4:	701a      	strb	r2, [r3, #0]
	udd_enable_stall_handshake(0);
   808a6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   808aa:	4b02      	ldr	r3, [pc, #8]	; (808b4 <udd_ctrl_stall_data+0x14>)
   808ac:	601a      	str	r2, [r3, #0]
   808ae:	4770      	bx	lr
   808b0:	2007069d 	.word	0x2007069d
   808b4:	400ac1f0 	.word	0x400ac1f0

000808b8 <udd_ctrl_send_zlp_in>:

static void udd_ctrl_send_zlp_in(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
   808b8:	2203      	movs	r2, #3
   808ba:	4b0d      	ldr	r3, [pc, #52]	; (808f0 <udd_ctrl_send_zlp_in+0x38>)
   808bc:	701a      	strb	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   808be:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   808c2:	b672      	cpsid	i
   808c4:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   808c8:	2100      	movs	r1, #0
   808ca:	4a0a      	ldr	r2, [pc, #40]	; (808f4 <udd_ctrl_send_zlp_in+0x3c>)
   808cc:	7011      	strb	r1, [r2, #0]

	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
   808ce:	480a      	ldr	r0, [pc, #40]	; (808f8 <udd_ctrl_send_zlp_in+0x40>)
   808d0:	2101      	movs	r1, #1
   808d2:	6001      	str	r1, [r0, #0]
	udd_enable_in_send_interrupt(0);
   808d4:	4a09      	ldr	r2, [pc, #36]	; (808fc <udd_ctrl_send_zlp_in+0x44>)
   808d6:	6011      	str	r1, [r2, #0]
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
   808d8:	2108      	movs	r1, #8
   808da:	6001      	str	r1, [r0, #0]
	udd_enable_nak_out_interrupt(0);
   808dc:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   808de:	b92b      	cbnz	r3, 808ec <udd_ctrl_send_zlp_in+0x34>
		cpu_irq_enable();
   808e0:	2201      	movs	r2, #1
   808e2:	4b04      	ldr	r3, [pc, #16]	; (808f4 <udd_ctrl_send_zlp_in+0x3c>)
   808e4:	701a      	strb	r2, [r3, #0]
   808e6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   808ea:	b662      	cpsie	i
   808ec:	4770      	bx	lr
   808ee:	bf00      	nop
   808f0:	2007069d 	.word	0x2007069d
   808f4:	20070206 	.word	0x20070206
   808f8:	400ac160 	.word	0x400ac160
   808fc:	400ac1f0 	.word	0x400ac1f0

00080900 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
   80900:	b508      	push	{r3, lr}
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
   80902:	4b02      	ldr	r3, [pc, #8]	; (8090c <udd_ctrl_endofrequest+0xc>)
   80904:	691b      	ldr	r3, [r3, #16]
   80906:	b103      	cbz	r3, 8090a <udd_ctrl_endofrequest+0xa>
		udd_g_ctrlreq.callback();
   80908:	4798      	blx	r3
   8090a:	bd08      	pop	{r3, pc}
   8090c:	20070720 	.word	0x20070720

00080910 <udd_ctrl_in_sent>:
	}
}


static void udd_ctrl_in_sent(void)
{
   80910:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80912:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80916:	b672      	cpsid	i
   80918:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8091c:	2100      	movs	r1, #0
   8091e:	4a48      	ldr	r2, [pc, #288]	; (80a40 <udd_ctrl_in_sent+0x130>)
   80920:	7011      	strb	r1, [r2, #0]
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
	udd_disable_in_send_interrupt(0);
   80922:	2101      	movs	r1, #1
   80924:	4a47      	ldr	r2, [pc, #284]	; (80a44 <udd_ctrl_in_sent+0x134>)
   80926:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80928:	b923      	cbnz	r3, 80934 <udd_ctrl_in_sent+0x24>
		cpu_irq_enable();
   8092a:	4b45      	ldr	r3, [pc, #276]	; (80a40 <udd_ctrl_in_sent+0x130>)
   8092c:	7019      	strb	r1, [r3, #0]
   8092e:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80932:	b662      	cpsie	i
	cpu_irq_restore(flags);

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   80934:	4b44      	ldr	r3, [pc, #272]	; (80a48 <udd_ctrl_in_sent+0x138>)
   80936:	781b      	ldrb	r3, [r3, #0]
   80938:	2b03      	cmp	r3, #3
   8093a:	d104      	bne.n	80946 <udd_ctrl_in_sent+0x36>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
   8093c:	4b43      	ldr	r3, [pc, #268]	; (80a4c <udd_ctrl_in_sent+0x13c>)
   8093e:	4798      	blx	r3
		// Reinitializes control endpoint management
		udd_ctrl_init();
   80940:	4b43      	ldr	r3, [pc, #268]	; (80a50 <udd_ctrl_in_sent+0x140>)
   80942:	4798      	blx	r3
		return;
   80944:	bd38      	pop	{r3, r4, r5, pc}
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   80946:	4b43      	ldr	r3, [pc, #268]	; (80a54 <udd_ctrl_in_sent+0x144>)
   80948:	881a      	ldrh	r2, [r3, #0]
   8094a:	4b43      	ldr	r3, [pc, #268]	; (80a58 <udd_ctrl_in_sent+0x148>)
   8094c:	899c      	ldrh	r4, [r3, #12]
   8094e:	1aa4      	subs	r4, r4, r2
   80950:	b2a4      	uxth	r4, r4
	if (0 == nb_remain) {
   80952:	2c00      	cmp	r4, #0
   80954:	d12e      	bne.n	809b4 <udd_ctrl_in_sent+0xa4>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous playlaod buffer
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   80956:	4941      	ldr	r1, [pc, #260]	; (80a5c <udd_ctrl_in_sent+0x14c>)
   80958:	880b      	ldrh	r3, [r1, #0]
   8095a:	4413      	add	r3, r2
   8095c:	b29b      	uxth	r3, r3
   8095e:	800b      	strh	r3, [r1, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_buf_cnt)
   80960:	4a3d      	ldr	r2, [pc, #244]	; (80a58 <udd_ctrl_in_sent+0x148>)
   80962:	88d2      	ldrh	r2, [r2, #6]
   80964:	429a      	cmp	r2, r3
   80966:	d002      	beq.n	8096e <udd_ctrl_in_sent+0x5e>
					|| b_shortpacket) {
   80968:	4b3d      	ldr	r3, [pc, #244]	; (80a60 <udd_ctrl_in_sent+0x150>)
   8096a:	781b      	ldrb	r3, [r3, #0]
   8096c:	b1c3      	cbz	r3, 809a0 <udd_ctrl_in_sent+0x90>

static void udd_ctrl_send_zlp_out(void)
{
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   8096e:	2204      	movs	r2, #4
   80970:	4b35      	ldr	r3, [pc, #212]	; (80a48 <udd_ctrl_in_sent+0x138>)
   80972:	701a      	strb	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80974:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80978:	b672      	cpsid	i
   8097a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8097e:	2100      	movs	r1, #0
   80980:	4a2f      	ldr	r2, [pc, #188]	; (80a40 <udd_ctrl_in_sent+0x130>)
   80982:	7011      	strb	r1, [r2, #0]
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
	udd_ack_nak_in(0);
   80984:	2210      	movs	r2, #16
   80986:	4937      	ldr	r1, [pc, #220]	; (80a64 <udd_ctrl_in_sent+0x154>)
   80988:	600a      	str	r2, [r1, #0]
	udd_enable_nak_in_interrupt(0);
   8098a:	3190      	adds	r1, #144	; 0x90
   8098c:	600a      	str	r2, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8098e:	2b00      	cmp	r3, #0
   80990:	d154      	bne.n	80a3c <udd_ctrl_in_sent+0x12c>
		cpu_irq_enable();
   80992:	2201      	movs	r2, #1
   80994:	4b2a      	ldr	r3, [pc, #168]	; (80a40 <udd_ctrl_in_sent+0x130>)
   80996:	701a      	strb	r2, [r3, #0]
   80998:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   8099c:	b662      	cpsie	i
   8099e:	bd38      	pop	{r3, r4, r5, pc}
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
			return;
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
   809a0:	4b2d      	ldr	r3, [pc, #180]	; (80a58 <udd_ctrl_in_sent+0x148>)
   809a2:	695b      	ldr	r3, [r3, #20]
   809a4:	b16b      	cbz	r3, 809c2 <udd_ctrl_in_sent+0xb2>
				|| (!udd_g_ctrlreq.over_under_run())) {
   809a6:	4798      	blx	r3
   809a8:	b158      	cbz	r0, 809c2 <udd_ctrl_in_sent+0xb2>
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_buf_cnt = 0;
   809aa:	2200      	movs	r2, #0
   809ac:	4b29      	ldr	r3, [pc, #164]	; (80a54 <udd_ctrl_in_sent+0x144>)
   809ae:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
   809b0:	4b29      	ldr	r3, [pc, #164]	; (80a58 <udd_ctrl_in_sent+0x148>)
   809b2:	899c      	ldrh	r4, [r3, #12]
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
   809b4:	2c07      	cmp	r4, #7
   809b6:	d904      	bls.n	809c2 <udd_ctrl_in_sent+0xb2>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
		b_shortpacket = false;
   809b8:	2200      	movs	r2, #0
   809ba:	4b29      	ldr	r3, [pc, #164]	; (80a60 <udd_ctrl_in_sent+0x150>)
   809bc:	701a      	strb	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
   809be:	2408      	movs	r4, #8
   809c0:	e002      	b.n	809c8 <udd_ctrl_in_sent+0xb8>
		b_shortpacket = false;
	} else {
		b_shortpacket = true;
   809c2:	2201      	movs	r2, #1
   809c4:	4b26      	ldr	r3, [pc, #152]	; (80a60 <udd_ctrl_in_sent+0x150>)
   809c6:	701a      	strb	r2, [r3, #0]
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   809c8:	4b23      	ldr	r3, [pc, #140]	; (80a58 <udd_ctrl_in_sent+0x148>)
   809ca:	689a      	ldr	r2, [r3, #8]
   809cc:	4b21      	ldr	r3, [pc, #132]	; (80a54 <udd_ctrl_in_sent+0x144>)
   809ce:	881b      	ldrh	r3, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   809d0:	f3ef 8010 	mrs	r0, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   809d4:	fab0 f080 	clz	r0, r0
   809d8:	0940      	lsrs	r0, r0, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   809da:	b672      	cpsid	i
   809dc:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   809e0:	2500      	movs	r5, #0
   809e2:	4917      	ldr	r1, [pc, #92]	; (80a40 <udd_ctrl_in_sent+0x130>)
   809e4:	700d      	strb	r5, [r1, #0]
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is recevied the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
   809e6:	4920      	ldr	r1, [pc, #128]	; (80a68 <udd_ctrl_in_sent+0x158>)
   809e8:	6809      	ldr	r1, [r1, #0]
   809ea:	f011 0f02 	tst.w	r1, #2
   809ee:	d101      	bne.n	809f4 <udd_ctrl_in_sent+0xe4>
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
   809f0:	b95c      	cbnz	r4, 80a0a <udd_ctrl_in_sent+0xfa>
   809f2:	e013      	b.n	80a1c <udd_ctrl_in_sent+0x10c>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   809f4:	b128      	cbz	r0, 80a02 <udd_ctrl_in_sent+0xf2>
		cpu_irq_enable();
   809f6:	2201      	movs	r2, #1
   809f8:	4b11      	ldr	r3, [pc, #68]	; (80a40 <udd_ctrl_in_sent+0x130>)
   809fa:	701a      	strb	r2, [r3, #0]
   809fc:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80a00:	b662      	cpsie	i
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
	if (Is_udd_out_received(0)) {
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   80a02:	2204      	movs	r2, #4
   80a04:	4b10      	ldr	r3, [pc, #64]	; (80a48 <udd_ctrl_in_sent+0x138>)
   80a06:	701a      	strb	r2, [r3, #0]
		return; // Exit of IN DATA phase
   80a08:	bd38      	pop	{r3, r4, r5, pc}
	} else {
		b_shortpacket = true;
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   80a0a:	441a      	add	r2, r3
   80a0c:	4b17      	ldr	r3, [pc, #92]	; (80a6c <udd_ctrl_in_sent+0x15c>)
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
		*ptr_dest++ = *ptr_src++;
   80a0e:	f812 1b01 	ldrb.w	r1, [r2], #1
   80a12:	f803 1b01 	strb.w	r1, [r3], #1
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
   80a16:	b2d9      	uxtb	r1, r3
   80a18:	42a1      	cmp	r1, r4
   80a1a:	d3f8      	bcc.n	80a0e <udd_ctrl_in_sent+0xfe>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_remain;
   80a1c:	4a0d      	ldr	r2, [pc, #52]	; (80a54 <udd_ctrl_in_sent+0x144>)
   80a1e:	8813      	ldrh	r3, [r2, #0]
   80a20:	441c      	add	r4, r3
   80a22:	8014      	strh	r4, [r2, #0]

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
   80a24:	2301      	movs	r3, #1
   80a26:	4a0f      	ldr	r2, [pc, #60]	; (80a64 <udd_ctrl_in_sent+0x154>)
   80a28:	6013      	str	r3, [r2, #0]
	udd_enable_in_send_interrupt(0);
   80a2a:	3290      	adds	r2, #144	; 0x90
   80a2c:	6013      	str	r3, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80a2e:	b128      	cbz	r0, 80a3c <udd_ctrl_in_sent+0x12c>
		cpu_irq_enable();
   80a30:	461a      	mov	r2, r3
   80a32:	4b03      	ldr	r3, [pc, #12]	; (80a40 <udd_ctrl_in_sent+0x130>)
   80a34:	701a      	strb	r2, [r3, #0]
   80a36:	f3bf 8f5f 	dmb	sy
   80a3a:	b662      	cpsie	i
   80a3c:	bd38      	pop	{r3, r4, r5, pc}
   80a3e:	bf00      	nop
   80a40:	20070206 	.word	0x20070206
   80a44:	400ac220 	.word	0x400ac220
   80a48:	2007069d 	.word	0x2007069d
   80a4c:	00080901 	.word	0x00080901
   80a50:	00080855 	.word	0x00080855
   80a54:	2007069e 	.word	0x2007069e
   80a58:	20070720 	.word	0x20070720
   80a5c:	2007069a 	.word	0x2007069a
   80a60:	200706a0 	.word	0x200706a0
   80a64:	400ac160 	.word	0x400ac160
   80a68:	400ac130 	.word	0x400ac130
   80a6c:	20180000 	.word	0x20180000

00080a70 <udd_ep_finish_job>:
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
   80a70:	b510      	push	{r4, lr}
   80a72:	4603      	mov	r3, r0
	if (ptr_job->busy == false) {
   80a74:	7d04      	ldrb	r4, [r0, #20]
   80a76:	f014 0f01 	tst.w	r4, #1
   80a7a:	d010      	beq.n	80a9e <udd_ep_finish_job+0x2e>
		return; // No on-going job
	}
	dbg_print("(JobE%x:%d) ", (ptr_job-udd_ep_job)+1, b_abort);
	ptr_job->busy = false;
   80a7c:	7d04      	ldrb	r4, [r0, #20]
   80a7e:	f36f 0400 	bfc	r4, #0, #1
   80a82:	7504      	strb	r4, [r0, #20]
	if (NULL == ptr_job->call_trans) {
   80a84:	6804      	ldr	r4, [r0, #0]
   80a86:	b154      	cbz	r4, 80a9e <udd_ep_finish_job+0x2e>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_in(ep_num)) {
   80a88:	4805      	ldr	r0, [pc, #20]	; (80aa0 <udd_ep_finish_job+0x30>)
   80a8a:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
   80a8e:	f410 7f80 	tst.w	r0, #256	; 0x100
		ep_num |= USB_EP_DIR_IN;
   80a92:	bf18      	it	ne
   80a94:	f042 0280 	orrne.w	r2, r2, #128	; 0x80
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
   80a98:	4608      	mov	r0, r1
   80a9a:	6899      	ldr	r1, [r3, #8]
   80a9c:	47a0      	blx	r4
   80a9e:	bd10      	pop	{r4, pc}
   80aa0:	400ac100 	.word	0x400ac100

00080aa4 <udd_ep_trans_done>:
			UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}

#ifdef UDD_EP_DMA_SUPPORTED
static void udd_ep_trans_done(udd_ep_id_t ep)
{
   80aa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
   80aa6:	1e43      	subs	r3, r0, #1

	if (!ptr_job->busy) {
   80aa8:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   80aac:	4a5a      	ldr	r2, [pc, #360]	; (80c18 <udd_ep_trans_done+0x174>)
   80aae:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   80ab2:	7d12      	ldrb	r2, [r2, #20]
   80ab4:	f012 0f01 	tst.w	r2, #1
   80ab8:	f000 80ad 	beq.w	80c16 <udd_ep_trans_done+0x172>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->buf_cnt != ptr_job->buf_size) {
   80abc:	460a      	mov	r2, r1
   80abe:	4956      	ldr	r1, [pc, #344]	; (80c18 <udd_ep_trans_done+0x174>)
   80ac0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   80ac4:	68d1      	ldr	r1, [r2, #12]
   80ac6:	6892      	ldr	r2, [r2, #8]
   80ac8:	4291      	cmp	r1, r2
   80aca:	d075      	beq.n	80bb8 <udd_ep_trans_done+0x114>
		// Need to send or receiv other data
		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;
   80acc:	1a52      	subs	r2, r2, r1

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
   80ace:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
			next_trans = UDD_ENDPOINT_MAX_TRANS;

			// Set 0 to tranfer the maximum
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
		} else {
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
   80ad2:	bf92      	itee	ls
   80ad4:	0417      	lslls	r7, r2, #16
		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
			// The USB hardware support a maximum
			// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
			next_trans = UDD_ENDPOINT_MAX_TRANS;
   80ad6:	f44f 3280 	movhi.w	r2, #65536	; 0x10000

			// Set 0 to tranfer the maximum
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
   80ada:	2700      	movhi	r7, #0
		} else {
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
		}
		if (Is_udd_endpoint_in(ep)) {
   80adc:	4c4f      	ldr	r4, [pc, #316]	; (80c1c <udd_ep_trans_done+0x178>)
   80ade:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   80ae2:	f415 7f80 	tst.w	r5, #256	; 0x100
   80ae6:	d014      	beq.n	80b12 <udd_ep_trans_done+0x6e>
			if (0 != (next_trans % udd_get_endpoint_size(ep))) {
   80ae8:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   80aec:	f3c5 1502 	ubfx	r5, r5, #4, #3
   80af0:	2408      	movs	r4, #8
   80af2:	40ac      	lsls	r4, r5
   80af4:	3c01      	subs	r4, #1
   80af6:	4222      	tst	r2, r4
   80af8:	d01b      	beq.n	80b32 <udd_ep_trans_done+0x8e>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_B_EN;
   80afa:	f047 0708 	orr.w	r7, r7, #8
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
   80afe:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   80b02:	4d45      	ldr	r5, [pc, #276]	; (80c18 <udd_ep_trans_done+0x174>)
   80b04:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
   80b08:	7d25      	ldrb	r5, [r4, #20]
   80b0a:	f36f 0541 	bfc	r5, #1, #1
   80b0e:	7525      	strb	r5, [r4, #20]
   80b10:	e00f      	b.n	80b32 <udd_ep_trans_done+0x8e>
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
   80b12:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   80b16:	f3c5 25c1 	ubfx	r5, r5, #11, #2
   80b1a:	2d01      	cmp	r5, #1
   80b1c:	d107      	bne.n	80b2e <udd_ep_trans_done+0x8a>
					|| (next_trans <= (iram_size_t) udd_get_endpoint_size(ep))) {
   80b1e:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   80b22:	f3c5 1502 	ubfx	r5, r5, #4, #3
   80b26:	2408      	movs	r4, #8
   80b28:	40ac      	lsls	r4, r5
   80b2a:	42a2      	cmp	r2, r4
   80b2c:	d801      	bhi.n	80b32 <udd_ep_trans_done+0x8e>

				// Enable short packet reception
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_TR_IT
   80b2e:	f047 0714 	orr.w	r7, r7, #20
						| UOTGHS_DEVDMACONTROL_END_TR_EN;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
   80b32:	4c3b      	ldr	r4, [pc, #236]	; (80c20 <udd_ep_trans_done+0x17c>)
   80b34:	eb04 1400 	add.w	r4, r4, r0, lsl #4
   80b38:	eb03 0543 	add.w	r5, r3, r3, lsl #1
   80b3c:	4e36      	ldr	r6, [pc, #216]	; (80c18 <udd_ep_trans_done+0x174>)
   80b3e:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
   80b42:	686d      	ldr	r5, [r5, #4]
   80b44:	4429      	add	r1, r5
   80b46:	6061      	str	r1, [r4, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80b48:	f3ef 8110 	mrs	r1, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   80b4c:	fab1 f181 	clz	r1, r1
   80b50:	0949      	lsrs	r1, r1, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80b52:	b672      	cpsid	i
   80b54:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   80b58:	2600      	movs	r6, #0
   80b5a:	4d32      	ldr	r5, [pc, #200]	; (80c24 <udd_ep_trans_done+0x180>)
   80b5c:	702e      	strb	r6, [r5, #0]


		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if (!(udd_endpoint_dma_get_status(ep)
   80b5e:	68e5      	ldr	r5, [r4, #12]
   80b60:	f015 0f10 	tst.w	r5, #16
   80b64:	d11a      	bne.n	80b9c <udd_ep_trans_done+0xf8>
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
		udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_BUFFIT |
   80b66:	f047 0721 	orr.w	r7, r7, #33	; 0x21
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if (!(udd_endpoint_dma_get_status(ep)
				& UOTGHS_DEVDMASTATUS_END_TR_ST)) {
			dbg_print("dmaS%x ", ep);
			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
   80b6a:	60a7      	str	r7, [r4, #8]
			ptr_job->buf_cnt += next_trans;
   80b6c:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   80b70:	4829      	ldr	r0, [pc, #164]	; (80c18 <udd_ep_trans_done+0x174>)
   80b72:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   80b76:	68c4      	ldr	r4, [r0, #12]
   80b78:	4414      	add	r4, r2
   80b7a:	60c4      	str	r4, [r0, #12]
			ptr_job->buf_load = next_trans;
   80b7c:	6102      	str	r2, [r0, #16]
			udd_enable_endpoint_dma_interrupt(ep);
   80b7e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   80b82:	fa02 f303 	lsl.w	r3, r2, r3
   80b86:	4a28      	ldr	r2, [pc, #160]	; (80c28 <udd_ep_trans_done+0x184>)
   80b88:	6193      	str	r3, [r2, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80b8a:	2900      	cmp	r1, #0
   80b8c:	d043      	beq.n	80c16 <udd_ep_trans_done+0x172>
		cpu_irq_enable();
   80b8e:	2201      	movs	r2, #1
   80b90:	4b24      	ldr	r3, [pc, #144]	; (80c24 <udd_ep_trans_done+0x180>)
   80b92:	701a      	strb	r2, [r3, #0]
   80b94:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80b98:	b662      	cpsie	i
   80b9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80b9c:	b129      	cbz	r1, 80baa <udd_ep_trans_done+0x106>
		cpu_irq_enable();
   80b9e:	2101      	movs	r1, #1
   80ba0:	4a20      	ldr	r2, [pc, #128]	; (80c24 <udd_ep_trans_done+0x180>)
   80ba2:	7011      	strb	r1, [r2, #0]
   80ba4:	f3bf 8f5f 	dmb	sy
   80ba8:	b662      	cpsie	i
		cpu_irq_restore(flags);

		// Here a ZLP has been recieved
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->buf_cnt;
   80baa:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   80bae:	491a      	ldr	r1, [pc, #104]	; (80c18 <udd_ep_trans_done+0x174>)
   80bb0:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   80bb4:	68d1      	ldr	r1, [r2, #12]
   80bb6:	6091      	str	r1, [r2, #8]
	}
	if (Is_udd_endpoint_in(ep)) {
   80bb8:	4a18      	ldr	r2, [pc, #96]	; (80c1c <udd_ep_trans_done+0x178>)
   80bba:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
   80bbe:	f412 7f80 	tst.w	r2, #256	; 0x100
   80bc2:	d01f      	beq.n	80c04 <udd_ep_trans_done+0x160>
		if (ptr_job->b_shortpacket) {
   80bc4:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   80bc8:	4913      	ldr	r1, [pc, #76]	; (80c18 <udd_ep_trans_done+0x174>)
   80bca:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   80bce:	7d12      	ldrb	r2, [r2, #20]
   80bd0:	f012 0f02 	tst.w	r2, #2
   80bd4:	d016      	beq.n	80c04 <udd_ep_trans_done+0x160>
			dbg_print("zlpS%x ", ep);
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			udd_ack_in_send(ep);
   80bd6:	2201      	movs	r2, #1
   80bd8:	4b14      	ldr	r3, [pc, #80]	; (80c2c <udd_ep_trans_done+0x188>)
   80bda:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
			if (Is_udd_write_enabled(ep)) {
   80bde:	3b30      	subs	r3, #48	; 0x30
   80be0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   80be4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
				// Force interrupt in case of ep already free
				udd_raise_in_send(ep);
   80be8:	bf1c      	itt	ne
   80bea:	4b11      	ldrne	r3, [pc, #68]	; (80c30 <udd_ep_trans_done+0x18c>)
   80bec:	f843 2020 	strne.w	r2, [r3, r0, lsl #2]
			}
			udd_enable_in_send_interrupt(ep);
   80bf0:	2201      	movs	r2, #1
   80bf2:	4b10      	ldr	r3, [pc, #64]	; (80c34 <udd_ep_trans_done+0x190>)
   80bf4:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
			udd_enable_endpoint_interrupt(ep);
   80bf8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   80bfc:	4083      	lsls	r3, r0
   80bfe:	4a0a      	ldr	r2, [pc, #40]	; (80c28 <udd_ep_trans_done+0x184>)
   80c00:	6193      	str	r3, [r2, #24]
			return;
   80c02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80c04:	4602      	mov	r2, r0
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
   80c06:	eb03 0343 	add.w	r3, r3, r3, lsl #1
			return;
		}
	}
	dbg_print("dmaE ");
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
   80c0a:	4803      	ldr	r0, [pc, #12]	; (80c18 <udd_ep_trans_done+0x174>)
   80c0c:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   80c10:	2100      	movs	r1, #0
   80c12:	4b09      	ldr	r3, [pc, #36]	; (80c38 <udd_ep_trans_done+0x194>)
   80c14:	4798      	blx	r3
   80c16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   80c18:	20070680 	.word	0x20070680
   80c1c:	400ac100 	.word	0x400ac100
   80c20:	400ac300 	.word	0x400ac300
   80c24:	20070206 	.word	0x20070206
   80c28:	400ac000 	.word	0x400ac000
   80c2c:	400ac160 	.word	0x400ac160
   80c30:	400ac190 	.word	0x400ac190
   80c34:	400ac1f0 	.word	0x400ac1f0
   80c38:	00080a71 	.word	0x00080a71

00080c3c <udd_sleep_mode>:
/*! \brief Authorize or not the CPU powerdown mode
 *
 * \param b_enable true to authorize idle mode
 */
static void udd_sleep_mode(bool b_idle)
{
   80c3c:	b410      	push	{r4}
	if (!b_idle && udd_b_idle) {
   80c3e:	4604      	mov	r4, r0
   80c40:	2800      	cmp	r0, #0
   80c42:	d135      	bne.n	80cb0 <udd_sleep_mode+0x74>
   80c44:	4b1e      	ldr	r3, [pc, #120]	; (80cc0 <udd_sleep_mode+0x84>)
   80c46:	781b      	ldrb	r3, [r3, #0]
   80c48:	b37b      	cbz	r3, 80caa <udd_sleep_mode+0x6e>
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
   80c4a:	4b1e      	ldr	r3, [pc, #120]	; (80cc4 <udd_sleep_mode+0x88>)
   80c4c:	789b      	ldrb	r3, [r3, #2]
   80c4e:	b903      	cbnz	r3, 80c52 <udd_sleep_mode+0x16>
   80c50:	e7fe      	b.n	80c50 <udd_sleep_mode+0x14>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80c52:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80c56:	b672      	cpsid	i
   80c58:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   80c5c:	2100      	movs	r1, #0
   80c5e:	4a1a      	ldr	r2, [pc, #104]	; (80cc8 <udd_sleep_mode+0x8c>)
   80c60:	7011      	strb	r1, [r2, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
   80c62:	4918      	ldr	r1, [pc, #96]	; (80cc4 <udd_sleep_mode+0x88>)
   80c64:	788a      	ldrb	r2, [r1, #2]
   80c66:	3a01      	subs	r2, #1
   80c68:	708a      	strb	r2, [r1, #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80c6a:	b9f3      	cbnz	r3, 80caa <udd_sleep_mode+0x6e>
		cpu_irq_enable();
   80c6c:	2201      	movs	r2, #1
   80c6e:	4b16      	ldr	r3, [pc, #88]	; (80cc8 <udd_sleep_mode+0x8c>)
   80c70:	701a      	strb	r2, [r3, #0]
   80c72:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80c76:	b662      	cpsie	i
   80c78:	e017      	b.n	80caa <udd_sleep_mode+0x6e>
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
   80c7a:	4b12      	ldr	r3, [pc, #72]	; (80cc4 <udd_sleep_mode+0x88>)
   80c7c:	789b      	ldrb	r3, [r3, #2]
   80c7e:	2bff      	cmp	r3, #255	; 0xff
   80c80:	d100      	bne.n	80c84 <udd_sleep_mode+0x48>
   80c82:	e7fe      	b.n	80c82 <udd_sleep_mode+0x46>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80c84:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80c88:	b672      	cpsid	i
   80c8a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   80c8e:	2100      	movs	r1, #0
   80c90:	4a0d      	ldr	r2, [pc, #52]	; (80cc8 <udd_sleep_mode+0x8c>)
   80c92:	7011      	strb	r1, [r2, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
   80c94:	490b      	ldr	r1, [pc, #44]	; (80cc4 <udd_sleep_mode+0x88>)
   80c96:	788a      	ldrb	r2, [r1, #2]
   80c98:	3201      	adds	r2, #1
   80c9a:	708a      	strb	r2, [r1, #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80c9c:	b92b      	cbnz	r3, 80caa <udd_sleep_mode+0x6e>
		cpu_irq_enable();
   80c9e:	2201      	movs	r2, #1
   80ca0:	4b09      	ldr	r3, [pc, #36]	; (80cc8 <udd_sleep_mode+0x8c>)
   80ca2:	701a      	strb	r2, [r3, #0]
   80ca4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80ca8:	b662      	cpsie	i
	}
	if (b_idle && !udd_b_idle) {
		dbg_print("_W ");
		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
   80caa:	4b05      	ldr	r3, [pc, #20]	; (80cc0 <udd_sleep_mode+0x84>)
   80cac:	701c      	strb	r4, [r3, #0]
   80cae:	e004      	b.n	80cba <udd_sleep_mode+0x7e>
{
	if (!b_idle && udd_b_idle) {
		dbg_print("_S ");
		sleepmgr_unlock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
	}
	if (b_idle && !udd_b_idle) {
   80cb0:	4b03      	ldr	r3, [pc, #12]	; (80cc0 <udd_sleep_mode+0x84>)
   80cb2:	781b      	ldrb	r3, [r3, #0]
   80cb4:	2b00      	cmp	r3, #0
   80cb6:	d1f8      	bne.n	80caa <udd_sleep_mode+0x6e>
   80cb8:	e7df      	b.n	80c7a <udd_sleep_mode+0x3e>
		dbg_print("_W ");
		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_IDLE);
	}
	udd_b_idle = b_idle;
}
   80cba:	f85d 4b04 	ldr.w	r4, [sp], #4
   80cbe:	4770      	bx	lr
   80cc0:	2007069c 	.word	0x2007069c
   80cc4:	20070718 	.word	0x20070718
   80cc8:	20070206 	.word	0x20070206

00080ccc <udd_enable>:
	return true;
}


void udd_enable(void)
{
   80ccc:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80cce:	f3ef 8410 	mrs	r4, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80cd2:	b672      	cpsid	i
   80cd4:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   80cd8:	2200      	movs	r2, #0
   80cda:	4b4b      	ldr	r3, [pc, #300]	; (80e08 <udd_enable+0x13c>)
   80cdc:	701a      	strb	r2, [r3, #0]
		cpu_irq_restore(flags);
		return;
	}
#else
	// SINGLE DEVICE MODE INITIALIZATION
	pmc_enable_periph_clk(ID_UOTGHS);
   80cde:	2028      	movs	r0, #40	; 0x28
   80ce0:	4b4a      	ldr	r3, [pc, #296]	; (80e0c <udd_enable+0x140>)
   80ce2:	4798      	blx	r3
	sysclk_enable_usb();
   80ce4:	4b4a      	ldr	r3, [pc, #296]	; (80e10 <udd_enable+0x144>)
   80ce6:	4798      	blx	r3
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   80ce8:	4b4a      	ldr	r3, [pc, #296]	; (80e14 <udd_enable+0x148>)
   80cea:	2250      	movs	r2, #80	; 0x50
   80cec:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328

    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   80cf0:	f44f 7280 	mov.w	r2, #256	; 0x100
   80cf4:	605a      	str	r2, [r3, #4]
	NVIC_SetPriority((IRQn_Type) ID_UOTGHS, UDD_USB_INT_LEVEL);
	NVIC_EnableIRQ((IRQn_Type) ID_UOTGHS);

	// Always authorize asynchrone USB interrupts to exit of sleep mode
	// For SAM USB wake up device except BACKUP mode
	pmc_set_fast_startup_input(PMC_FSMR_USBAL);
   80cf6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   80cfa:	4b47      	ldr	r3, [pc, #284]	; (80e18 <udd_enable+0x14c>)
   80cfc:	4798      	blx	r3
		cpu_irq_restore(flags);
		return; // Device is not the current mode
	}
#else
	// ID pin not used then force device mode
	otg_disable_id_pin();
   80cfe:	4b47      	ldr	r3, [pc, #284]	; (80e1c <udd_enable+0x150>)
   80d00:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d04:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
   80d08:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_force_device_mode();
   80d0c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d10:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
   80d14:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
   80d18:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d1c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
   80d20:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
	// Enable USB hardware
	otg_enable_pad();
   80d24:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d28:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   80d2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_enable();
   80d30:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d34:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
   80d38:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
   80d3c:	681a      	ldr	r2, [r3, #0]
   80d3e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
   80d42:	601a      	str	r2, [r3, #0]
# ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
# else
	udd_high_speed_disable();
   80d44:	681a      	ldr	r2, [r3, #0]
   80d46:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
   80d4a:	601a      	str	r2, [r3, #0]
# endif
#endif // USB_DEVICE_LOW_SPEED

	// Check USB clock
	otg_unfreeze_clock();
   80d4c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d50:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   80d54:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	while (!Is_otg_clock_usable());
   80d58:	461a      	mov	r2, r3
   80d5a:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
   80d5e:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   80d62:	d0fa      	beq.n	80d5a <udd_enable+0x8e>
   80d64:	e03d      	b.n	80de2 <udd_enable+0x116>

	otg_ack_vbus_transition();
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
		otg_raise_vbus_transition();
   80d66:	2202      	movs	r2, #2
   80d68:	4b2c      	ldr	r3, [pc, #176]	; (80e1c <udd_enable+0x150>)
   80d6a:	f8c3 280c 	str.w	r2, [r3, #2060]	; 0x80c
	}
	otg_enable_vbus_interrupt();
   80d6e:	4b2b      	ldr	r3, [pc, #172]	; (80e1c <udd_enable+0x150>)
   80d70:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d74:	f042 0202 	orr.w	r2, r2, #2
   80d78:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	otg_freeze_clock();
   80d7c:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80d80:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   80d84:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

#ifndef UDD_NO_SLEEP_MGR
	if (!udd_b_sleep_initialized) {
   80d88:	4b25      	ldr	r3, [pc, #148]	; (80e20 <udd_enable+0x154>)
   80d8a:	781b      	ldrb	r3, [r3, #0]
   80d8c:	b9f3      	cbnz	r3, 80dcc <udd_enable+0x100>
		udd_b_sleep_initialized = true;
   80d8e:	2201      	movs	r2, #1
   80d90:	4b23      	ldr	r3, [pc, #140]	; (80e20 <udd_enable+0x154>)
   80d92:	701a      	strb	r2, [r3, #0]
		// Initialize the sleep mode authorized for the USB suspend mode
		udd_b_idle = false;
   80d94:	2200      	movs	r2, #0
   80d96:	4b23      	ldr	r3, [pc, #140]	; (80e24 <udd_enable+0x158>)
   80d98:	701a      	strb	r2, [r3, #0]
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] >= 0xff) {
   80d9a:	4b23      	ldr	r3, [pc, #140]	; (80e28 <udd_enable+0x15c>)
   80d9c:	78db      	ldrb	r3, [r3, #3]
   80d9e:	2bff      	cmp	r3, #255	; 0xff
   80da0:	d100      	bne.n	80da4 <udd_enable+0xd8>
   80da2:	e7fe      	b.n	80da2 <udd_enable+0xd6>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80da4:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80da8:	b672      	cpsid	i
   80daa:	f3bf 8f5f 	dmb	sy
   80dae:	2100      	movs	r1, #0
   80db0:	4a15      	ldr	r2, [pc, #84]	; (80e08 <udd_enable+0x13c>)
   80db2:	7011      	strb	r1, [r2, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
   80db4:	491c      	ldr	r1, [pc, #112]	; (80e28 <udd_enable+0x15c>)
   80db6:	78ca      	ldrb	r2, [r1, #3]
   80db8:	3201      	adds	r2, #1
   80dba:	70ca      	strb	r2, [r1, #3]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80dbc:	b94b      	cbnz	r3, 80dd2 <udd_enable+0x106>
		cpu_irq_enable();
   80dbe:	2201      	movs	r2, #1
   80dc0:	4b11      	ldr	r3, [pc, #68]	; (80e08 <udd_enable+0x13c>)
   80dc2:	701a      	strb	r2, [r3, #0]
   80dc4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80dc8:	b662      	cpsie	i
   80dca:	e002      	b.n	80dd2 <udd_enable+0x106>
		sleepmgr_lock_mode(UOTGHS_SLEEP_MODE_USB_SUSPEND);
	} else {
		udd_sleep_mode(false); // Enter idle mode
   80dcc:	2000      	movs	r0, #0
   80dce:	4b17      	ldr	r3, [pc, #92]	; (80e2c <udd_enable+0x160>)
   80dd0:	4798      	blx	r3
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80dd2:	b9bc      	cbnz	r4, 80e04 <udd_enable+0x138>
		cpu_irq_enable();
   80dd4:	2201      	movs	r2, #1
   80dd6:	4b0c      	ldr	r3, [pc, #48]	; (80e08 <udd_enable+0x13c>)
   80dd8:	701a      	strb	r2, [r3, #0]
   80dda:	f3bf 8f5f 	dmb	sy
   80dde:	b662      	cpsie	i
   80de0:	bd10      	pop	{r4, pc}

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_job[i].busy = false;
   80de2:	4a13      	ldr	r2, [pc, #76]	; (80e30 <udd_enable+0x164>)
   80de4:	7d13      	ldrb	r3, [r2, #20]
		udd_ep_job[i].stall_requested = false;
   80de6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
   80dea:	f36f 0382 	bfc	r3, #2, #1
   80dee:	7513      	strb	r3, [r2, #20]
	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	udd_ep_job_table_reset();
#endif

	otg_ack_vbus_transition();
   80df0:	4b0a      	ldr	r3, [pc, #40]	; (80e1c <udd_enable+0x150>)
   80df2:	2202      	movs	r2, #2
   80df4:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
   80df8:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   80dfc:	f413 6f00 	tst.w	r3, #2048	; 0x800
   80e00:	d1b1      	bne.n	80d66 <udd_enable+0x9a>
   80e02:	e7b4      	b.n	80d6e <udd_enable+0xa2>
   80e04:	bd10      	pop	{r4, pc}
   80e06:	bf00      	nop
   80e08:	20070206 	.word	0x20070206
   80e0c:	00082031 	.word	0x00082031
   80e10:	00081b71 	.word	0x00081b71
   80e14:	e000e100 	.word	0xe000e100
   80e18:	000820a5 	.word	0x000820a5
   80e1c:	400ac000 	.word	0x400ac000
   80e20:	20070698 	.word	0x20070698
   80e24:	2007069c 	.word	0x2007069c
   80e28:	20070718 	.word	0x20070718
   80e2c:	00080c3d 	.word	0x00080c3d
   80e30:	20070680 	.word	0x20070680

00080e34 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
   80e34:	b538      	push	{r3, r4, r5, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80e36:	f3ef 8410 	mrs	r4, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80e3a:	b672      	cpsid	i
   80e3c:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   80e40:	2200      	movs	r2, #0
   80e42:	4b18      	ldr	r3, [pc, #96]	; (80ea4 <udd_attach+0x70>)
   80e44:	701a      	strb	r2, [r3, #0]
	irqflags_t flags;
	flags = cpu_irq_save();

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
   80e46:	2001      	movs	r0, #1
   80e48:	4b17      	ldr	r3, [pc, #92]	; (80ea8 <udd_attach+0x74>)
   80e4a:	4798      	blx	r3
	otg_unfreeze_clock();
   80e4c:	4a17      	ldr	r2, [pc, #92]	; (80eac <udd_attach+0x78>)
   80e4e:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
   80e52:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   80e56:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800

	// This section of clock check can be improved with a chek of
	// USB clock source via sysclk()
	// Check USB clock because the source can be a PLL
	while (!Is_otg_clock_usable());
   80e5a:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
   80e5e:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   80e62:	d0fa      	beq.n	80e5a <udd_attach+0x26>

	// Authorize attach if Vbus is present
	udd_attach_device();
   80e64:	4b11      	ldr	r3, [pc, #68]	; (80eac <udd_attach+0x78>)
   80e66:	681a      	ldr	r2, [r3, #0]
   80e68:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   80e6c:	601a      	str	r2, [r3, #0]

	// Enable USB line events
	udd_enable_reset_interrupt();
   80e6e:	2508      	movs	r5, #8
   80e70:	619d      	str	r5, [r3, #24]
	udd_enable_suspend_interrupt();
   80e72:	2101      	movs	r1, #1
   80e74:	6199      	str	r1, [r3, #24]
	udd_enable_wake_up_interrupt();
   80e76:	2210      	movs	r2, #16
   80e78:	619a      	str	r2, [r3, #24]
	udd_enable_sof_interrupt();
   80e7a:	2004      	movs	r0, #4
   80e7c:	6198      	str	r0, [r3, #24]
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interupts flag
	udd_ack_reset();
   80e7e:	609d      	str	r5, [r3, #8]
	udd_ack_sof();
   80e80:	6098      	str	r0, [r3, #8]
	udd_ack_msof();
   80e82:	2002      	movs	r0, #2
   80e84:	6098      	str	r0, [r3, #8]

	// The first suspend interrupt must be forced
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
   80e86:	60d9      	str	r1, [r3, #12]

	udd_ack_wake_up();
   80e88:	609a      	str	r2, [r3, #8]
	otg_freeze_clock();
   80e8a:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80e8e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   80e92:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80e96:	b924      	cbnz	r4, 80ea2 <udd_attach+0x6e>
		cpu_irq_enable();
   80e98:	4b02      	ldr	r3, [pc, #8]	; (80ea4 <udd_attach+0x70>)
   80e9a:	7019      	strb	r1, [r3, #0]
   80e9c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   80ea0:	b662      	cpsie	i
   80ea2:	bd38      	pop	{r3, r4, r5, pc}
   80ea4:	20070206 	.word	0x20070206
   80ea8:	00080c3d 	.word	0x00080c3d
   80eac:	400ac000 	.word	0x400ac000

00080eb0 <udd_detach>:
	cpu_irq_restore(flags);
}


void udd_detach(void)
{
   80eb0:	b508      	push	{r3, lr}
	otg_unfreeze_clock();
   80eb2:	4b0a      	ldr	r3, [pc, #40]	; (80edc <udd_detach+0x2c>)
   80eb4:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80eb8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   80ebc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

	// Detach device from the bus
	udd_detach_device();
   80ec0:	681a      	ldr	r2, [r3, #0]
   80ec2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   80ec6:	601a      	str	r2, [r3, #0]
	otg_freeze_clock();
   80ec8:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   80ecc:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   80ed0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	udd_sleep_mode(false);
   80ed4:	2000      	movs	r0, #0
   80ed6:	4b02      	ldr	r3, [pc, #8]	; (80ee0 <udd_detach+0x30>)
   80ed8:	4798      	blx	r3
   80eda:	bd08      	pop	{r3, pc}
   80edc:	400ac000 	.word	0x400ac000
   80ee0:	00080c3d 	.word	0x00080c3d

00080ee4 <UOTGHS_Handler>:
void udd_interrupt(void);
void udd_interrupt(void)
#else
ISR(UDD_USB_INT_FUN)
#endif
{
   80ee4:	b510      	push	{r4, lr}
	/* For fast wakeup clocks restore
	 * In WAIT mode, clocks are switched to FASTRC.
	 * After wakeup clocks should be restored, before that ISR should not
	 * be served.
	 */
	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
   80ee6:	4b91      	ldr	r3, [pc, #580]	; (8112c <UOTGHS_Handler+0x248>)
   80ee8:	4798      	blx	r3
   80eea:	b958      	cbnz	r0, 80f04 <UOTGHS_Handler+0x20>
   80eec:	4b90      	ldr	r3, [pc, #576]	; (81130 <UOTGHS_Handler+0x24c>)
   80eee:	685b      	ldr	r3, [r3, #4]
   80ef0:	f013 0f01 	tst.w	r3, #1
   80ef4:	d106      	bne.n	80f04 <UOTGHS_Handler+0x20>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80ef6:	b672      	cpsid	i
   80ef8:	f3bf 8f5f 	dmb	sy
		cpu_irq_disable();
   80efc:	2200      	movs	r2, #0
   80efe:	4b8d      	ldr	r3, [pc, #564]	; (81134 <UOTGHS_Handler+0x250>)
   80f00:	701a      	strb	r2, [r3, #0]
		return;
   80f02:	bd10      	pop	{r4, pc}
	}

	if (Is_udd_sof()) {
   80f04:	4b8a      	ldr	r3, [pc, #552]	; (81130 <UOTGHS_Handler+0x24c>)
   80f06:	685b      	ldr	r3, [r3, #4]
   80f08:	f013 0f04 	tst.w	r3, #4
   80f0c:	d00b      	beq.n	80f26 <UOTGHS_Handler+0x42>
		udd_ack_sof();
   80f0e:	4b88      	ldr	r3, [pc, #544]	; (81130 <UOTGHS_Handler+0x24c>)
   80f10:	2204      	movs	r2, #4
   80f12:	609a      	str	r2, [r3, #8]
		if (Is_udd_full_speed_mode()) {
   80f14:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   80f18:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   80f1c:	f040 827a 	bne.w	81414 <UOTGHS_Handler+0x530>
			udc_sof_notify();
   80f20:	4b85      	ldr	r3, [pc, #532]	; (81138 <UOTGHS_Handler+0x254>)
   80f22:	4798      	blx	r3
   80f24:	bd10      	pop	{r4, pc}
		UDC_SOF_EVENT();
#endif
		goto udd_interrupt_sof_end;
	}

	if (Is_udd_msof()) {
   80f26:	4b82      	ldr	r3, [pc, #520]	; (81130 <UOTGHS_Handler+0x24c>)
   80f28:	685b      	ldr	r3, [r3, #4]
   80f2a:	f013 0f02 	tst.w	r3, #2
   80f2e:	d005      	beq.n	80f3c <UOTGHS_Handler+0x58>
		udd_ack_msof();
   80f30:	2202      	movs	r2, #2
   80f32:	4b7f      	ldr	r3, [pc, #508]	; (81130 <UOTGHS_Handler+0x24c>)
   80f34:	609a      	str	r2, [r3, #8]
		udc_sof_notify();
   80f36:	4b80      	ldr	r3, [pc, #512]	; (81138 <UOTGHS_Handler+0x254>)
   80f38:	4798      	blx	r3
		goto udd_interrupt_sof_end;
   80f3a:	bd10      	pop	{r4, pc}


static bool udd_ctrl_interrupt(void)
{

	if (!Is_udd_endpoint_interrupt(0)) {
   80f3c:	4b7c      	ldr	r3, [pc, #496]	; (81130 <UOTGHS_Handler+0x24c>)
   80f3e:	685b      	ldr	r3, [r3, #4]
   80f40:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   80f44:	f000 8259 	beq.w	813fa <UOTGHS_Handler+0x516>
	}

	dbg_print("0: ");

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
   80f48:	4b7c      	ldr	r3, [pc, #496]	; (8113c <UOTGHS_Handler+0x258>)
   80f4a:	2210      	movs	r2, #16
   80f4c:	601a      	str	r2, [r3, #0]
	udd_disable_nak_out_interrupt(0);
   80f4e:	2208      	movs	r2, #8
   80f50:	601a      	str	r2, [r3, #0]

	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
   80f52:	3bf0      	subs	r3, #240	; 0xf0
   80f54:	681b      	ldr	r3, [r3, #0]
   80f56:	f013 0f04 	tst.w	r3, #4
   80f5a:	d054      	beq.n	81006 <UOTGHS_Handler+0x122>
static void udd_ctrl_setup_received(void)
{
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
   80f5c:	4b78      	ldr	r3, [pc, #480]	; (81140 <UOTGHS_Handler+0x25c>)
   80f5e:	781b      	ldrb	r3, [r3, #0]
   80f60:	2b00      	cmp	r3, #0
   80f62:	f000 823f 	beq.w	813e4 <UOTGHS_Handler+0x500>
		// May be a hidden DATA or ZLP phase or protocol abort
		udd_ctrl_endofrequest();
   80f66:	4b77      	ldr	r3, [pc, #476]	; (81144 <UOTGHS_Handler+0x260>)
   80f68:	4798      	blx	r3

		// Reinitializes control endpoint management
		udd_ctrl_init();
   80f6a:	4b77      	ldr	r3, [pc, #476]	; (81148 <UOTGHS_Handler+0x264>)
   80f6c:	4798      	blx	r3
   80f6e:	e239      	b.n	813e4 <UOTGHS_Handler+0x500>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
		udd_ctrl_stall_data();
   80f70:	4b76      	ldr	r3, [pc, #472]	; (8114c <UOTGHS_Handler+0x268>)
   80f72:	4798      	blx	r3
		udd_ack_setup_received(0);
   80f74:	2204      	movs	r2, #4
   80f76:	4b76      	ldr	r3, [pc, #472]	; (81150 <UOTGHS_Handler+0x26c>)
   80f78:	601a      	str	r2, [r3, #0]
   80f7a:	bd10      	pop	{r4, pc}
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
   80f7c:	f813 1b01 	ldrb.w	r1, [r3], #1
   80f80:	f802 1f01 	strb.w	r1, [r2, #1]!
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
   80f84:	4283      	cmp	r3, r0
   80f86:	d1f9      	bne.n	80f7c <UOTGHS_Handler+0x98>
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);

	// Decode setup request
	if (udc_process_setup() == false) {
   80f88:	4b72      	ldr	r3, [pc, #456]	; (81154 <UOTGHS_Handler+0x270>)
   80f8a:	4798      	blx	r3
   80f8c:	b928      	cbnz	r0, 80f9a <UOTGHS_Handler+0xb6>
		// Setup request unknow then stall it
		udd_ctrl_stall_data();
   80f8e:	4b6f      	ldr	r3, [pc, #444]	; (8114c <UOTGHS_Handler+0x268>)
   80f90:	4798      	blx	r3
		udd_ack_setup_received(0);
   80f92:	2204      	movs	r2, #4
   80f94:	4b6e      	ldr	r3, [pc, #440]	; (81150 <UOTGHS_Handler+0x26c>)
   80f96:	601a      	str	r2, [r3, #0]
   80f98:	bd10      	pop	{r4, pc}
		return;
	}
	udd_ack_setup_received(0);
   80f9a:	2204      	movs	r2, #4
   80f9c:	4b6c      	ldr	r3, [pc, #432]	; (81150 <UOTGHS_Handler+0x26c>)
   80f9e:	601a      	str	r2, [r3, #0]

	if (Udd_setup_is_in()) {
   80fa0:	4b6d      	ldr	r3, [pc, #436]	; (81158 <UOTGHS_Handler+0x274>)
   80fa2:	f993 3000 	ldrsb.w	r3, [r3]
   80fa6:	2b00      	cmp	r3, #0
   80fa8:	da0a      	bge.n	80fc0 <UOTGHS_Handler+0xdc>
		// IN data phase requested
		udd_ctrl_prev_payload_buf_cnt = 0;
   80faa:	2300      	movs	r3, #0
   80fac:	4a6b      	ldr	r2, [pc, #428]	; (8115c <UOTGHS_Handler+0x278>)
   80fae:	8013      	strh	r3, [r2, #0]
		udd_ctrl_payload_buf_cnt = 0;
   80fb0:	4a6b      	ldr	r2, [pc, #428]	; (81160 <UOTGHS_Handler+0x27c>)
   80fb2:	8013      	strh	r3, [r2, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
   80fb4:	2202      	movs	r2, #2
   80fb6:	4b62      	ldr	r3, [pc, #392]	; (81140 <UOTGHS_Handler+0x25c>)
   80fb8:	701a      	strb	r2, [r3, #0]
		udd_ctrl_in_sent(); // Send first data transfer
   80fba:	4b6a      	ldr	r3, [pc, #424]	; (81164 <UOTGHS_Handler+0x280>)
   80fbc:	4798      	blx	r3
   80fbe:	bd10      	pop	{r4, pc}
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
   80fc0:	4b65      	ldr	r3, [pc, #404]	; (81158 <UOTGHS_Handler+0x274>)
   80fc2:	88db      	ldrh	r3, [r3, #6]
   80fc4:	b913      	cbnz	r3, 80fcc <UOTGHS_Handler+0xe8>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
   80fc6:	4b68      	ldr	r3, [pc, #416]	; (81168 <UOTGHS_Handler+0x284>)
   80fc8:	4798      	blx	r3
   80fca:	bd10      	pop	{r4, pc}
			return;
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_buf_cnt = 0;
   80fcc:	2200      	movs	r2, #0
   80fce:	4b63      	ldr	r3, [pc, #396]	; (8115c <UOTGHS_Handler+0x278>)
   80fd0:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_buf_cnt = 0;
   80fd2:	4b63      	ldr	r3, [pc, #396]	; (81160 <UOTGHS_Handler+0x27c>)
   80fd4:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
   80fd6:	2101      	movs	r1, #1
   80fd8:	4b59      	ldr	r3, [pc, #356]	; (81140 <UOTGHS_Handler+0x25c>)
   80fda:	7019      	strb	r1, [r3, #0]
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
   80fdc:	2110      	movs	r1, #16
   80fde:	4b5c      	ldr	r3, [pc, #368]	; (81150 <UOTGHS_Handler+0x26c>)
   80fe0:	6019      	str	r1, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   80fe2:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   80fe6:	b672      	cpsid	i
   80fe8:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   80fec:	4851      	ldr	r0, [pc, #324]	; (81134 <UOTGHS_Handler+0x250>)
   80fee:	7002      	strb	r2, [r0, #0]
		flags = cpu_irq_save();
		udd_enable_nak_in_interrupt(0);
   80ff0:	4a5e      	ldr	r2, [pc, #376]	; (8116c <UOTGHS_Handler+0x288>)
   80ff2:	6011      	str	r1, [r2, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   80ff4:	2b00      	cmp	r3, #0
   80ff6:	f040 820d 	bne.w	81414 <UOTGHS_Handler+0x530>
		cpu_irq_enable();
   80ffa:	2201      	movs	r2, #1
   80ffc:	7002      	strb	r2, [r0, #0]
   80ffe:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   81002:	b662      	cpsie	i
   81004:	bd10      	pop	{r4, pc}
		dbg_print("stup ");
		// SETUP packet received
		udd_ctrl_setup_received();
		return true;
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
   81006:	4b5a      	ldr	r3, [pc, #360]	; (81170 <UOTGHS_Handler+0x28c>)
   81008:	681b      	ldr	r3, [r3, #0]
   8100a:	f013 0f01 	tst.w	r3, #1
   8100e:	d007      	beq.n	81020 <UOTGHS_Handler+0x13c>
   81010:	4b58      	ldr	r3, [pc, #352]	; (81174 <UOTGHS_Handler+0x290>)
   81012:	681b      	ldr	r3, [r3, #0]
   81014:	f013 0f01 	tst.w	r3, #1
   81018:	d002      	beq.n	81020 <UOTGHS_Handler+0x13c>
		dbg_print("in ");
		// IN packet sent
		udd_ctrl_in_sent();
   8101a:	4b52      	ldr	r3, [pc, #328]	; (81164 <UOTGHS_Handler+0x280>)
   8101c:	4798      	blx	r3
   8101e:	bd10      	pop	{r4, pc}
		return true;
	}
	if (Is_udd_out_received(0)) {
   81020:	4b53      	ldr	r3, [pc, #332]	; (81170 <UOTGHS_Handler+0x28c>)
   81022:	681b      	ldr	r3, [r3, #0]
   81024:	f013 0f02 	tst.w	r3, #2
   81028:	f000 80a8 	beq.w	8117c <UOTGHS_Handler+0x298>
{
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
   8102c:	4b44      	ldr	r3, [pc, #272]	; (81140 <UOTGHS_Handler+0x25c>)
   8102e:	781b      	ldrb	r3, [r3, #0]
   81030:	2b01      	cmp	r3, #1
   81032:	d00b      	beq.n	8104c <UOTGHS_Handler+0x168>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
   81034:	2b02      	cmp	r3, #2
   81036:	d001      	beq.n	8103c <UOTGHS_Handler+0x158>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
   81038:	2b04      	cmp	r3, #4
   8103a:	d102      	bne.n	81042 <UOTGHS_Handler+0x15e>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quiclky,
			// - or ZLP OUT received normaly.
			udd_ctrl_endofrequest();
   8103c:	4b41      	ldr	r3, [pc, #260]	; (81144 <UOTGHS_Handler+0x260>)
   8103e:	4798      	blx	r3
   81040:	e001      	b.n	81046 <UOTGHS_Handler+0x162>
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
   81042:	4b42      	ldr	r3, [pc, #264]	; (8114c <UOTGHS_Handler+0x268>)
   81044:	4798      	blx	r3
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
   81046:	4b40      	ldr	r3, [pc, #256]	; (81148 <UOTGHS_Handler+0x264>)
   81048:	4798      	blx	r3
   8104a:	bd10      	pop	{r4, pc}
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
   8104c:	4b48      	ldr	r3, [pc, #288]	; (81170 <UOTGHS_Handler+0x28c>)
   8104e:	6818      	ldr	r0, [r3, #0]
   81050:	f3c0 500a 	ubfx	r0, r0, #20, #11
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
   81054:	4b40      	ldr	r3, [pc, #256]	; (81158 <UOTGHS_Handler+0x274>)
   81056:	899b      	ldrh	r3, [r3, #12]
   81058:	4a41      	ldr	r2, [pc, #260]	; (81160 <UOTGHS_Handler+0x27c>)
   8105a:	8814      	ldrh	r4, [r2, #0]
   8105c:	1822      	adds	r2, r4, r0
   8105e:	4293      	cmp	r3, r2
		// Reinitializes control endpoint management
		udd_ctrl_init();
		return;
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
   81060:	bfae      	itee	ge
   81062:	b280      	uxthge	r0, r0
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   81064:	1b1b      	sublt	r3, r3, r4
   81066:	b298      	uxthlt	r0, r3
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   81068:	4b3b      	ldr	r3, [pc, #236]	; (81158 <UOTGHS_Handler+0x274>)
   8106a:	689a      	ldr	r2, [r3, #8]
	for (i = 0; i < nb_data; i++) {
   8106c:	b1b0      	cbz	r0, 8109c <UOTGHS_Handler+0x1b8>
   8106e:	1e63      	subs	r3, r4, #1
   81070:	441a      	add	r2, r3
   81072:	4b41      	ldr	r3, [pc, #260]	; (81178 <UOTGHS_Handler+0x294>)
		*ptr_dest++ = *ptr_src++;
   81074:	f813 1b01 	ldrb.w	r1, [r3], #1
   81078:	f802 1f01 	strb.w	r1, [r2, #1]!
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
	for (i = 0; i < nb_data; i++) {
   8107c:	b2d9      	uxtb	r1, r3
   8107e:	4281      	cmp	r1, r0
   81080:	d3f8      	bcc.n	81074 <UOTGHS_Handler+0x190>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_data;
   81082:	4404      	add	r4, r0
   81084:	b2a4      	uxth	r4, r4
   81086:	4b36      	ldr	r3, [pc, #216]	; (81160 <UOTGHS_Handler+0x27c>)
   81088:	801c      	strh	r4, [r3, #0]

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
   8108a:	2808      	cmp	r0, #8
   8108c:	d106      	bne.n	8109c <UOTGHS_Handler+0x1b8>
			|| (udd_g_ctrlreq.req.wLength <=
   8108e:	4b32      	ldr	r3, [pc, #200]	; (81158 <UOTGHS_Handler+0x274>)
   81090:	88da      	ldrh	r2, [r3, #6]
					(udd_ctrl_prev_payload_buf_cnt +
   81092:	4b32      	ldr	r3, [pc, #200]	; (8115c <UOTGHS_Handler+0x278>)
   81094:	881b      	ldrh	r3, [r3, #0]
   81096:	4423      	add	r3, r4
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_buf_cnt += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
			|| (udd_g_ctrlreq.req.wLength <=
   81098:	429a      	cmp	r2, r3
   8109a:	dc11      	bgt.n	810c0 <UOTGHS_Handler+0x1dc>
					(udd_ctrl_prev_payload_buf_cnt +
							udd_ctrl_payload_buf_cnt))) {
		// End of reception because it is a short packet
		// Before send ZLP, call intermediat calback
		// in case of data receiv generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;
   8109c:	4b2e      	ldr	r3, [pc, #184]	; (81158 <UOTGHS_Handler+0x274>)
   8109e:	819c      	strh	r4, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
   810a0:	695b      	ldr	r3, [r3, #20]
   810a2:	b13b      	cbz	r3, 810b4 <UOTGHS_Handler+0x1d0>
			if (!udd_g_ctrlreq.over_under_run()) {
   810a4:	4798      	blx	r3
   810a6:	b928      	cbnz	r0, 810b4 <UOTGHS_Handler+0x1d0>
				// Stall ZLP
				udd_ctrl_stall_data();
   810a8:	4b28      	ldr	r3, [pc, #160]	; (8114c <UOTGHS_Handler+0x268>)
   810aa:	4798      	blx	r3
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
   810ac:	2202      	movs	r2, #2
   810ae:	4b28      	ldr	r3, [pc, #160]	; (81150 <UOTGHS_Handler+0x26c>)
   810b0:	601a      	str	r2, [r3, #0]
   810b2:	bd10      	pop	{r4, pc}
				return;
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
   810b4:	2202      	movs	r2, #2
   810b6:	4b26      	ldr	r3, [pc, #152]	; (81150 <UOTGHS_Handler+0x26c>)
   810b8:	601a      	str	r2, [r3, #0]
		udd_ctrl_send_zlp_in();
   810ba:	4b2b      	ldr	r3, [pc, #172]	; (81168 <UOTGHS_Handler+0x284>)
   810bc:	4798      	blx	r3
   810be:	bd10      	pop	{r4, pc}
		return;
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_buf_cnt) {
   810c0:	4b25      	ldr	r3, [pc, #148]	; (81158 <UOTGHS_Handler+0x274>)
   810c2:	899b      	ldrh	r3, [r3, #12]
   810c4:	42a3      	cmp	r3, r4
   810c6:	d118      	bne.n	810fa <UOTGHS_Handler+0x216>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
   810c8:	4b23      	ldr	r3, [pc, #140]	; (81158 <UOTGHS_Handler+0x274>)
   810ca:	695b      	ldr	r3, [r3, #20]
   810cc:	b92b      	cbnz	r3, 810da <UOTGHS_Handler+0x1f6>
			// No callback availabled to request a new payload buffer
			udd_ctrl_stall_data();
   810ce:	4b1f      	ldr	r3, [pc, #124]	; (8114c <UOTGHS_Handler+0x268>)
   810d0:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
   810d2:	2202      	movs	r2, #2
   810d4:	4b1e      	ldr	r3, [pc, #120]	; (81150 <UOTGHS_Handler+0x26c>)
   810d6:	601a      	str	r2, [r3, #0]
   810d8:	bd10      	pop	{r4, pc}
			return;
		}
		if (!udd_g_ctrlreq.over_under_run()) {
   810da:	4798      	blx	r3
   810dc:	b928      	cbnz	r0, 810ea <UOTGHS_Handler+0x206>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
   810de:	4b1b      	ldr	r3, [pc, #108]	; (8114c <UOTGHS_Handler+0x268>)
   810e0:	4798      	blx	r3
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
   810e2:	2202      	movs	r2, #2
   810e4:	4b1a      	ldr	r3, [pc, #104]	; (81150 <UOTGHS_Handler+0x26c>)
   810e6:	601a      	str	r2, [r3, #0]
   810e8:	bd10      	pop	{r4, pc}
			return;
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   810ea:	491c      	ldr	r1, [pc, #112]	; (8115c <UOTGHS_Handler+0x278>)
   810ec:	4a1c      	ldr	r2, [pc, #112]	; (81160 <UOTGHS_Handler+0x27c>)
   810ee:	8810      	ldrh	r0, [r2, #0]
   810f0:	880b      	ldrh	r3, [r1, #0]
   810f2:	4403      	add	r3, r0
   810f4:	800b      	strh	r3, [r1, #0]
		// Reinit reception on payload buffer
		udd_ctrl_payload_buf_cnt = 0;
   810f6:	2300      	movs	r3, #0
   810f8:	8013      	strh	r3, [r2, #0]
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
   810fa:	4b15      	ldr	r3, [pc, #84]	; (81150 <UOTGHS_Handler+0x26c>)
   810fc:	2202      	movs	r2, #2
   810fe:	601a      	str	r2, [r3, #0]
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
   81100:	2210      	movs	r2, #16
   81102:	601a      	str	r2, [r3, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81104:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   81108:	b672      	cpsid	i
   8110a:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   8110e:	2000      	movs	r0, #0
   81110:	4908      	ldr	r1, [pc, #32]	; (81134 <UOTGHS_Handler+0x250>)
   81112:	7008      	strb	r0, [r1, #0]
	flags = cpu_irq_save();
	udd_enable_nak_in_interrupt(0);
   81114:	4915      	ldr	r1, [pc, #84]	; (8116c <UOTGHS_Handler+0x288>)
   81116:	600a      	str	r2, [r1, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81118:	2b00      	cmp	r3, #0
   8111a:	f040 817b 	bne.w	81414 <UOTGHS_Handler+0x530>
		cpu_irq_enable();
   8111e:	2201      	movs	r2, #1
   81120:	4b04      	ldr	r3, [pc, #16]	; (81134 <UOTGHS_Handler+0x250>)
   81122:	701a      	strb	r2, [r3, #0]
   81124:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   81128:	b662      	cpsie	i
   8112a:	bd10      	pop	{r4, pc}
   8112c:	000820b9 	.word	0x000820b9
   81130:	400ac000 	.word	0x400ac000
   81134:	20070206 	.word	0x20070206
   81138:	000803d9 	.word	0x000803d9
   8113c:	400ac220 	.word	0x400ac220
   81140:	2007069d 	.word	0x2007069d
   81144:	00080901 	.word	0x00080901
   81148:	00080855 	.word	0x00080855
   8114c:	000808a1 	.word	0x000808a1
   81150:	400ac160 	.word	0x400ac160
   81154:	00080415 	.word	0x00080415
   81158:	20070720 	.word	0x20070720
   8115c:	2007069a 	.word	0x2007069a
   81160:	2007069e 	.word	0x2007069e
   81164:	00080911 	.word	0x00080911
   81168:	000808b9 	.word	0x000808b9
   8116c:	400ac1f0 	.word	0x400ac1f0
   81170:	400ac130 	.word	0x400ac130
   81174:	400ac1c0 	.word	0x400ac1c0
   81178:	20180000 	.word	0x20180000
		dbg_print("out ");
		// OUT packet received
		udd_ctrl_out_received();
		return true;
	}
	if (Is_udd_nak_out(0)) {
   8117c:	4ba6      	ldr	r3, [pc, #664]	; (81418 <UOTGHS_Handler+0x534>)
   8117e:	681b      	ldr	r3, [r3, #0]
   81180:	f013 0f08 	tst.w	r3, #8
   81184:	d012      	beq.n	811ac <UOTGHS_Handler+0x2c8>
		dbg_print("nako ");
		// Overflow on OUT packet
		udd_ack_nak_out(0);
   81186:	2208      	movs	r2, #8
   81188:	4ba4      	ldr	r3, [pc, #656]	; (8141c <UOTGHS_Handler+0x538>)
   8118a:	601a      	str	r2, [r3, #0]
}


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
   8118c:	3b30      	subs	r3, #48	; 0x30
   8118e:	681b      	ldr	r3, [r3, #0]
   81190:	f013 0f01 	tst.w	r3, #1
   81194:	f040 813e 	bne.w	81414 <UOTGHS_Handler+0x530>
		return; // Overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   81198:	4ba1      	ldr	r3, [pc, #644]	; (81420 <UOTGHS_Handler+0x53c>)
   8119a:	781b      	ldrb	r3, [r3, #0]
   8119c:	2b03      	cmp	r3, #3
   8119e:	f040 8139 	bne.w	81414 <UOTGHS_Handler+0x530>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
   811a2:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   811a6:	4b9f      	ldr	r3, [pc, #636]	; (81424 <UOTGHS_Handler+0x540>)
   811a8:	601a      	str	r2, [r3, #0]
   811aa:	bd10      	pop	{r4, pc}
		// Overflow on OUT packet
		udd_ack_nak_out(0);
		udd_ctrl_overflow();
		return true;
	}
	if (Is_udd_nak_in(0)) {
   811ac:	4b9a      	ldr	r3, [pc, #616]	; (81418 <UOTGHS_Handler+0x534>)
   811ae:	681b      	ldr	r3, [r3, #0]
   811b0:	f013 0f10 	tst.w	r3, #16
   811b4:	f000 8121 	beq.w	813fa <UOTGHS_Handler+0x516>
		dbg_print("naki ");
		// Underflow on IN packet
		udd_ack_nak_in(0);
   811b8:	2210      	movs	r2, #16
   811ba:	4b98      	ldr	r3, [pc, #608]	; (8141c <UOTGHS_Handler+0x538>)
   811bc:	601a      	str	r2, [r3, #0]
}


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
   811be:	3b30      	subs	r3, #48	; 0x30
   811c0:	681b      	ldr	r3, [r3, #0]
   811c2:	f013 0f02 	tst.w	r3, #2
   811c6:	f040 8125 	bne.w	81414 <UOTGHS_Handler+0x530>
		return; // Underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
   811ca:	4b95      	ldr	r3, [pc, #596]	; (81420 <UOTGHS_Handler+0x53c>)
   811cc:	781b      	ldrb	r3, [r3, #0]
   811ce:	2b01      	cmp	r3, #1
   811d0:	d102      	bne.n	811d8 <UOTGHS_Handler+0x2f4>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
   811d2:	4b95      	ldr	r3, [pc, #596]	; (81428 <UOTGHS_Handler+0x544>)
   811d4:	4798      	blx	r3
   811d6:	bd10      	pop	{r4, pc}
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
   811d8:	2b04      	cmp	r3, #4
   811da:	f040 811b 	bne.w	81414 <UOTGHS_Handler+0x530>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
   811de:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   811e2:	4b90      	ldr	r3, [pc, #576]	; (81424 <UOTGHS_Handler+0x540>)
   811e4:	601a      	str	r2, [r3, #0]
   811e6:	bd10      	pop	{r4, pc}
		ptr_job = &udd_ep_job[ep - 1];

#ifdef UDD_EP_DMA_SUPPORTED
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
				&& Is_udd_endpoint_dma_interrupt(ep)) {
   811e8:	4b90      	ldr	r3, [pc, #576]	; (8142c <UOTGHS_Handler+0x548>)
   811ea:	685b      	ldr	r3, [r3, #4]
   811ec:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
   811f0:	d017      	beq.n	81222 <UOTGHS_Handler+0x33e>
			uint32_t nb_remaining;
			if (udd_endpoint_dma_get_status(ep)
   811f2:	4b8f      	ldr	r3, [pc, #572]	; (81430 <UOTGHS_Handler+0x54c>)
   811f4:	68db      	ldr	r3, [r3, #12]
   811f6:	f013 0f01 	tst.w	r3, #1
   811fa:	f040 810b 	bne.w	81414 <UOTGHS_Handler+0x530>
					& UOTGHS_DEVDMASTATUS_CHANN_ENB) {
				return true; // Ignore EOT_STA interrupt
			}
			dbg_print("dma%x: ", ep);
			udd_disable_endpoint_dma_interrupt(ep);
   811fe:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
   81202:	4b8a      	ldr	r3, [pc, #552]	; (8142c <UOTGHS_Handler+0x548>)
   81204:	615a      	str	r2, [r3, #20]
			// Save number of data no transfered
			nb_remaining = (udd_endpoint_dma_get_status(ep) &
   81206:	f503 7344 	add.w	r3, r3, #784	; 0x310
   8120a:	68db      	ldr	r3, [r3, #12]
					UOTGHS_DEVDMASTATUS_BUFF_COUNT_Msk)
					>> UOTGHS_DEVDMASTATUS_BUFF_COUNT_Pos;
			if (nb_remaining) {
   8120c:	0c1a      	lsrs	r2, r3, #16
   8120e:	d004      	beq.n	8121a <UOTGHS_Handler+0x336>
				// Transfer no complete (short packet or ZLP) then:
				// Update number of data transfered
				ptr_job->buf_cnt -= nb_remaining;
   81210:	4988      	ldr	r1, [pc, #544]	; (81434 <UOTGHS_Handler+0x550>)
   81212:	68cb      	ldr	r3, [r1, #12]
   81214:	1a9b      	subs	r3, r3, r2
   81216:	60cb      	str	r3, [r1, #12]
				// Set transfer complete to stop the transfer
				ptr_job->buf_size = ptr_job->buf_cnt;
   81218:	608b      	str	r3, [r1, #8]
			}
			udd_ep_trans_done(ep);
   8121a:	2001      	movs	r0, #1
   8121c:	4b86      	ldr	r3, [pc, #536]	; (81438 <UOTGHS_Handler+0x554>)
   8121e:	4798      	blx	r3
   81220:	bd10      	pop	{r4, pc}
				return true;
			}
		}
#endif // UDD_EP_FIFO_SUPPORTED
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
   81222:	4b82      	ldr	r3, [pc, #520]	; (8142c <UOTGHS_Handler+0x548>)
   81224:	691b      	ldr	r3, [r3, #16]
   81226:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   8122a:	f000 80ed 	beq.w	81408 <UOTGHS_Handler+0x524>
			dbg_print("bg%x: ", ep);
			if (Is_udd_in_send_interrupt_enabled(ep)
   8122e:	4b83      	ldr	r3, [pc, #524]	; (8143c <UOTGHS_Handler+0x558>)
   81230:	681b      	ldr	r3, [r3, #0]
   81232:	f013 0f01 	tst.w	r3, #1
   81236:	d011      	beq.n	8125c <UOTGHS_Handler+0x378>
					&& Is_udd_in_send(ep)) {
   81238:	4b81      	ldr	r3, [pc, #516]	; (81440 <UOTGHS_Handler+0x55c>)
   8123a:	681b      	ldr	r3, [r3, #0]
   8123c:	f013 0f01 	tst.w	r3, #1
   81240:	d00c      	beq.n	8125c <UOTGHS_Handler+0x378>
				dbg_print("I ");
				udd_disable_in_send_interrupt(ep);
   81242:	4b80      	ldr	r3, [pc, #512]	; (81444 <UOTGHS_Handler+0x560>)
   81244:	2201      	movs	r2, #1
   81246:	601a      	str	r2, [r3, #0]
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
   81248:	497f      	ldr	r1, [pc, #508]	; (81448 <UOTGHS_Handler+0x564>)
   8124a:	600a      	str	r2, [r1, #0]
				udd_ack_fifocon(ep);
   8124c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
   81250:	6019      	str	r1, [r3, #0]
				udd_ep_finish_job(ptr_job, false, ep);
   81252:	4878      	ldr	r0, [pc, #480]	; (81434 <UOTGHS_Handler+0x550>)
   81254:	2100      	movs	r1, #0
   81256:	4b7d      	ldr	r3, [pc, #500]	; (8144c <UOTGHS_Handler+0x568>)
   81258:	4798      	blx	r3
   8125a:	bd10      	pop	{r4, pc}
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep)
   8125c:	4b77      	ldr	r3, [pc, #476]	; (8143c <UOTGHS_Handler+0x558>)
   8125e:	681b      	ldr	r3, [r3, #0]
   81260:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   81264:	f000 80d0 	beq.w	81408 <UOTGHS_Handler+0x524>
					&& (0 == udd_nb_busy_bank(ep))) {
   81268:	4b75      	ldr	r3, [pc, #468]	; (81440 <UOTGHS_Handler+0x55c>)
   8126a:	681b      	ldr	r3, [r3, #0]
   8126c:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   81270:	f040 80ca 	bne.w	81408 <UOTGHS_Handler+0x524>
				dbg_print("EoT ");
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
   81274:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   81278:	4b72      	ldr	r3, [pc, #456]	; (81444 <UOTGHS_Handler+0x560>)
   8127a:	601a      	str	r2, [r3, #0]
				udd_disable_endpoint_interrupt(ep);
   8127c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   81280:	f5a3 7309 	sub.w	r3, r3, #548	; 0x224
   81284:	615a      	str	r2, [r3, #20]

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
   81286:	4b6b      	ldr	r3, [pc, #428]	; (81434 <UOTGHS_Handler+0x550>)
   81288:	7d1a      	ldrb	r2, [r3, #20]
   8128a:	f36f 0282 	bfc	r2, #2, #1
   8128e:	751a      	strb	r2, [r3, #20]
				udd_disable_endpoint_bank_autoswitch(ep);
   81290:	4a6f      	ldr	r2, [pc, #444]	; (81450 <UOTGHS_Handler+0x56c>)
   81292:	6813      	ldr	r3, [r2, #0]
   81294:	f423 7300 	bic.w	r3, r3, #512	; 0x200
   81298:	6013      	str	r3, [r2, #0]
				udd_enable_stall_handshake(ep);
   8129a:	4b6e      	ldr	r3, [pc, #440]	; (81454 <UOTGHS_Handler+0x570>)
   8129c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   812a0:	601a      	str	r2, [r3, #0]
				udd_reset_data_toggle(ep);
   812a2:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   812a6:	601a      	str	r2, [r3, #0]
   812a8:	bd10      	pop	{r4, pc}
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
		udd_ack_reset();
   812aa:	4c60      	ldr	r4, [pc, #384]	; (8142c <UOTGHS_Handler+0x548>)
   812ac:	2308      	movs	r3, #8
   812ae:	60a3      	str	r3, [r4, #8]
{
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
   812b0:	4860      	ldr	r0, [pc, #384]	; (81434 <UOTGHS_Handler+0x550>)
   812b2:	2101      	movs	r1, #1
   812b4:	460a      	mov	r2, r1
   812b6:	4b65      	ldr	r3, [pc, #404]	; (8144c <UOTGHS_Handler+0x568>)
   812b8:	4798      	blx	r3
		// Abort all jobs on-going
#if (USB_DEVICE_MAX_EP != 0)
		udd_ep_job_table_kill();
#endif
		// Reset USB Device Stack Core
		udc_reset();
   812ba:	4b67      	ldr	r3, [pc, #412]	; (81458 <UOTGHS_Handler+0x574>)
   812bc:	4798      	blx	r3
static void udd_reset_ep_ctrl(void)
{
	irqflags_t flags;

	// Reset USB address to 0
	udd_configure_address(0);
   812be:	6823      	ldr	r3, [r4, #0]
   812c0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   812c4:	6023      	str	r3, [r4, #0]
	udd_enable_address();
   812c6:	6823      	ldr	r3, [r4, #0]
   812c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   812cc:	6023      	str	r3, [r4, #0]

	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
   812ce:	4a63      	ldr	r2, [pc, #396]	; (8145c <UOTGHS_Handler+0x578>)
   812d0:	6813      	ldr	r3, [r2, #0]
   812d2:	f423 53cb 	bic.w	r3, r3, #6496	; 0x1960
   812d6:	f023 031c 	bic.w	r3, r3, #28
   812da:	6013      	str	r3, [r2, #0]
		USB_EP_TYPE_CONTROL,
		0,
		USB_DEVICE_EP_CTRL_SIZE,
		UOTGHS_DEVEPTCFG_EPBK_1_BANK);

	udd_allocate_memory(0);
   812dc:	6813      	ldr	r3, [r2, #0]
   812de:	f043 0302 	orr.w	r3, r3, #2
   812e2:	6013      	str	r3, [r2, #0]
	udd_enable_endpoint(0);
   812e4:	69e3      	ldr	r3, [r4, #28]
   812e6:	f043 0301 	orr.w	r3, r3, #1
   812ea:	61e3      	str	r3, [r4, #28]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   812ec:	f3ef 8310 	mrs	r3, PRIMASK
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   812f0:	b672      	cpsid	i
   812f2:	f3bf 8f5f 	dmb	sy
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
	cpu_irq_disable();
   812f6:	2100      	movs	r1, #0
   812f8:	4a59      	ldr	r2, [pc, #356]	; (81460 <UOTGHS_Handler+0x57c>)
   812fa:	7011      	strb	r1, [r2, #0]
	flags = cpu_irq_save();
	udd_enable_setup_received_interrupt(0);
   812fc:	4a49      	ldr	r2, [pc, #292]	; (81424 <UOTGHS_Handler+0x540>)
   812fe:	2104      	movs	r1, #4
   81300:	6011      	str	r1, [r2, #0]
	udd_enable_out_received_interrupt(0);
   81302:	2102      	movs	r1, #2
   81304:	6011      	str	r1, [r2, #0]
	udd_enable_endpoint_interrupt(0);
   81306:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   8130a:	61a2      	str	r2, [r4, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   8130c:	b92b      	cbnz	r3, 8131a <UOTGHS_Handler+0x436>
		cpu_irq_enable();
   8130e:	2201      	movs	r2, #1
   81310:	4b53      	ldr	r3, [pc, #332]	; (81460 <UOTGHS_Handler+0x57c>)
   81312:	701a      	strb	r2, [r3, #0]
   81314:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   81318:	b662      	cpsie	i
		// Reset USB Device Stack Core
		udc_reset();
		// Reset endpoint control
		udd_reset_ep_ctrl();
		// Reset endpoint control management
		udd_ctrl_init();
   8131a:	4b52      	ldr	r3, [pc, #328]	; (81464 <UOTGHS_Handler+0x580>)
   8131c:	4798      	blx	r3
		goto udd_interrupt_end;
   8131e:	bd10      	pop	{r4, pc}
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
   81320:	4b42      	ldr	r3, [pc, #264]	; (8142c <UOTGHS_Handler+0x548>)
   81322:	691b      	ldr	r3, [r3, #16]
   81324:	f013 0f01 	tst.w	r3, #1
   81328:	d019      	beq.n	8135e <UOTGHS_Handler+0x47a>
   8132a:	4b40      	ldr	r3, [pc, #256]	; (8142c <UOTGHS_Handler+0x548>)
   8132c:	685b      	ldr	r3, [r3, #4]
   8132e:	f013 0f01 	tst.w	r3, #1
   81332:	d014      	beq.n	8135e <UOTGHS_Handler+0x47a>
		otg_unfreeze_clock();
   81334:	4b3d      	ldr	r3, [pc, #244]	; (8142c <UOTGHS_Handler+0x548>)
   81336:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   8133a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   8133e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
   81342:	2201      	movs	r2, #1
   81344:	615a      	str	r2, [r3, #20]
		udd_enable_wake_up_interrupt();
   81346:	2210      	movs	r2, #16
   81348:	619a      	str	r2, [r3, #24]
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
   8134a:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   8134e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   81352:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		udd_sleep_mode(false);  // Enter in SUSPEND mode
   81356:	2000      	movs	r0, #0
   81358:	4b43      	ldr	r3, [pc, #268]	; (81468 <UOTGHS_Handler+0x584>)
   8135a:	4798      	blx	r3
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
#endif
		goto udd_interrupt_end;
   8135c:	bd10      	pop	{r4, pc}
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
   8135e:	4b33      	ldr	r3, [pc, #204]	; (8142c <UOTGHS_Handler+0x548>)
   81360:	691b      	ldr	r3, [r3, #16]
   81362:	f013 0f10 	tst.w	r3, #16
   81366:	d01e      	beq.n	813a6 <UOTGHS_Handler+0x4c2>
   81368:	4b30      	ldr	r3, [pc, #192]	; (8142c <UOTGHS_Handler+0x548>)
   8136a:	685b      	ldr	r3, [r3, #4]
   8136c:	f013 0f10 	tst.w	r3, #16
   81370:	d019      	beq.n	813a6 <UOTGHS_Handler+0x4c2>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
   81372:	4a2e      	ldr	r2, [pc, #184]	; (8142c <UOTGHS_Handler+0x548>)
   81374:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
   81378:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   8137c:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
		// Check USB clock ready after suspend and eventually sleep USB clock
		while (!Is_otg_clock_usable()) {
   81380:	4613      	mov	r3, r2
   81382:	e003      	b.n	8138c <UOTGHS_Handler+0x4a8>
			if (Is_udd_suspend()) {
   81384:	685a      	ldr	r2, [r3, #4]
   81386:	f012 0f01 	tst.w	r2, #1
   8138a:	d104      	bne.n	81396 <UOTGHS_Handler+0x4b2>

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
		// Check USB clock ready after suspend and eventually sleep USB clock
		while (!Is_otg_clock_usable()) {
   8138c:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
   81390:	f412 4f80 	tst.w	r2, #16384	; 0x4000
   81394:	d0f6      	beq.n	81384 <UOTGHS_Handler+0x4a0>
			if (Is_udd_suspend()) {
				break; // In case of USB state change in HS
			}
		};
		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
   81396:	4b25      	ldr	r3, [pc, #148]	; (8142c <UOTGHS_Handler+0x548>)
   81398:	2210      	movs	r2, #16
   8139a:	615a      	str	r2, [r3, #20]
		udd_enable_suspend_interrupt();
   8139c:	2001      	movs	r0, #1
   8139e:	6198      	str	r0, [r3, #24]
		udd_sleep_mode(true); // Enter in IDLE mode
   813a0:	4b31      	ldr	r3, [pc, #196]	; (81468 <UOTGHS_Handler+0x584>)
   813a2:	4798      	blx	r3
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
#endif
		goto udd_interrupt_end;
   813a4:	bd10      	pop	{r4, pc}
	}

	if (Is_otg_vbus_transition()) {
   813a6:	4b21      	ldr	r3, [pc, #132]	; (8142c <UOTGHS_Handler+0x548>)
   813a8:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   813ac:	f013 0f02 	tst.w	r3, #2
   813b0:	d030      	beq.n	81414 <UOTGHS_Handler+0x530>
		dbg_print("VBus ");
		// Ack Vbus transition and send status to high level
		otg_unfreeze_clock();
   813b2:	4b1e      	ldr	r3, [pc, #120]	; (8142c <UOTGHS_Handler+0x548>)
   813b4:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   813b8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   813bc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		otg_ack_vbus_transition();
   813c0:	2202      	movs	r2, #2
   813c2:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
		otg_freeze_clock();
   813c6:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   813ca:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   813ce:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
		if (Is_otg_vbus_high()) {
   813d2:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   813d6:	f413 6f00 	tst.w	r3, #2048	; 0x800
			udd_attach();
   813da:	bf14      	ite	ne
   813dc:	4b23      	ldrne	r3, [pc, #140]	; (8146c <UOTGHS_Handler+0x588>)
		} else {
			udd_detach();
   813de:	4b24      	ldreq	r3, [pc, #144]	; (81470 <UOTGHS_Handler+0x58c>)
   813e0:	4798      	blx	r3
   813e2:	bd10      	pop	{r4, pc}

		// Reinitializes control endpoint management
		udd_ctrl_init();
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
   813e4:	4b0c      	ldr	r3, [pc, #48]	; (81418 <UOTGHS_Handler+0x534>)
   813e6:	681b      	ldr	r3, [r3, #0]
   813e8:	f3c3 530a 	ubfx	r3, r3, #20, #11
   813ec:	2b08      	cmp	r3, #8
   813ee:	f47f adbf 	bne.w	80f70 <UOTGHS_Handler+0x8c>
   813f2:	4a20      	ldr	r2, [pc, #128]	; (81474 <UOTGHS_Handler+0x590>)
   813f4:	4b20      	ldr	r3, [pc, #128]	; (81478 <UOTGHS_Handler+0x594>)
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
   813f6:	4821      	ldr	r0, [pc, #132]	; (8147c <UOTGHS_Handler+0x598>)
   813f8:	e5c0      	b.n	80f7c <UOTGHS_Handler+0x98>
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];

#ifdef UDD_EP_DMA_SUPPORTED
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
   813fa:	4b0c      	ldr	r3, [pc, #48]	; (8142c <UOTGHS_Handler+0x548>)
   813fc:	691b      	ldr	r3, [r3, #16]
   813fe:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
   81402:	f47f aef1 	bne.w	811e8 <UOTGHS_Handler+0x304>
   81406:	e70c      	b.n	81222 <UOTGHS_Handler+0x33e>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
	}
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
   81408:	4b08      	ldr	r3, [pc, #32]	; (8142c <UOTGHS_Handler+0x548>)
   8140a:	685b      	ldr	r3, [r3, #4]
   8140c:	f013 0f08 	tst.w	r3, #8
   81410:	d086      	beq.n	81320 <UOTGHS_Handler+0x43c>
   81412:	e74a      	b.n	812aa <UOTGHS_Handler+0x3c6>
   81414:	bd10      	pop	{r4, pc}
   81416:	bf00      	nop
   81418:	400ac130 	.word	0x400ac130
   8141c:	400ac160 	.word	0x400ac160
   81420:	2007069d 	.word	0x2007069d
   81424:	400ac1f0 	.word	0x400ac1f0
   81428:	000808b9 	.word	0x000808b9
   8142c:	400ac000 	.word	0x400ac000
   81430:	400ac310 	.word	0x400ac310
   81434:	20070680 	.word	0x20070680
   81438:	00080aa5 	.word	0x00080aa5
   8143c:	400ac1c4 	.word	0x400ac1c4
   81440:	400ac134 	.word	0x400ac134
   81444:	400ac224 	.word	0x400ac224
   81448:	400ac164 	.word	0x400ac164
   8144c:	00080a71 	.word	0x00080a71
   81450:	400ac104 	.word	0x400ac104
   81454:	400ac1f4 	.word	0x400ac1f4
   81458:	00080391 	.word	0x00080391
   8145c:	400ac100 	.word	0x400ac100
   81460:	20070206 	.word	0x20070206
   81464:	00080855 	.word	0x00080855
   81468:	00080c3d 	.word	0x00080c3d
   8146c:	00080e35 	.word	0x00080e35
   81470:	00080eb1 	.word	0x00080eb1
   81474:	2007071f 	.word	0x2007071f
   81478:	20180000 	.word	0x20180000
   8147c:	20180008 	.word	0x20180008

00081480 <udd_set_address>:
}


void udd_set_address(uint8_t address)
{
	udd_disable_address();
   81480:	4b08      	ldr	r3, [pc, #32]	; (814a4 <udd_set_address+0x24>)
   81482:	681a      	ldr	r2, [r3, #0]
   81484:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   81488:	601a      	str	r2, [r3, #0]
	udd_configure_address(address);
   8148a:	681a      	ldr	r2, [r3, #0]
   8148c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   81490:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   81494:	4302      	orrs	r2, r0
   81496:	601a      	str	r2, [r3, #0]
	udd_enable_address();
   81498:	681a      	ldr	r2, [r3, #0]
   8149a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   8149e:	601a      	str	r2, [r3, #0]
   814a0:	4770      	bx	lr
   814a2:	bf00      	nop
   814a4:	400ac000 	.word	0x400ac000

000814a8 <udd_getaddress>:
}


uint8_t udd_getaddress(void)
{
	return udd_get_configured_address();
   814a8:	4b02      	ldr	r3, [pc, #8]	; (814b4 <udd_getaddress+0xc>)
   814aa:	6818      	ldr	r0, [r3, #0]
}
   814ac:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   814b0:	4770      	bx	lr
   814b2:	bf00      	nop
   814b4:	400ac000 	.word	0x400ac000

000814b8 <udd_set_setup_payload>:
}


void udd_set_setup_payload(uint8_t *payload, uint16_t payload_size)
{
	udd_g_ctrlreq.payload = payload;
   814b8:	4b01      	ldr	r3, [pc, #4]	; (814c0 <udd_set_setup_payload+0x8>)
   814ba:	6098      	str	r0, [r3, #8]
	udd_g_ctrlreq.payload_size = payload_size;
   814bc:	8199      	strh	r1, [r3, #12]
   814be:	4770      	bx	lr
   814c0:	20070720 	.word	0x20070720

000814c4 <udd_ep_free>:
}


void udd_ep_free(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   814c4:	f000 020f 	and.w	r2, r0, #15
	if (USB_DEVICE_MAX_EP < ep_index) {
   814c8:	2a01      	cmp	r2, #1
   814ca:	d821      	bhi.n	81510 <udd_ep_free+0x4c>
	return true;
}


void udd_ep_free(udd_ep_id_t ep)
{
   814cc:	b570      	push	{r4, r5, r6, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep_index) {
		return;
	}
	udd_disable_endpoint(ep_index);
   814ce:	4811      	ldr	r0, [pc, #68]	; (81514 <udd_ep_free+0x50>)
   814d0:	69c3      	ldr	r3, [r0, #28]
   814d2:	2101      	movs	r1, #1
   814d4:	fa01 f402 	lsl.w	r4, r1, r2
   814d8:	ea23 0304 	bic.w	r3, r3, r4
   814dc:	61c3      	str	r3, [r0, #28]
	udd_unallocate_memory(ep_index);
   814de:	f500 7080 	add.w	r0, r0, #256	; 0x100
   814e2:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
   814e6:	f023 0302 	bic.w	r3, r3, #2
   814ea:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
static void udd_ep_abort_job(udd_ep_id_t ep)
{
	ep &= USB_EP_ADDR_MASK;

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   814ee:	1e55      	subs	r5, r2, #1
   814f0:	4c09      	ldr	r4, [pc, #36]	; (81518 <udd_ep_free+0x54>)
   814f2:	fa05 f601 	lsl.w	r6, r5, r1
   814f6:	1970      	adds	r0, r6, r5
   814f8:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
   814fc:	4b07      	ldr	r3, [pc, #28]	; (8151c <udd_ep_free+0x58>)
   814fe:	4798      	blx	r3
		return;
	}
	udd_disable_endpoint(ep_index);
	udd_unallocate_memory(ep_index);
	udd_ep_abort_job(ep);
	udd_ep_job[ep_index - 1].stall_requested = false;
   81500:	4435      	add	r5, r6
   81502:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   81506:	7d23      	ldrb	r3, [r4, #20]
   81508:	f36f 0382 	bfc	r3, #2, #1
   8150c:	7523      	strb	r3, [r4, #20]
   8150e:	bd70      	pop	{r4, r5, r6, pc}
   81510:	4770      	bx	lr
   81512:	bf00      	nop
   81514:	400ac000 	.word	0x400ac000
   81518:	20070680 	.word	0x20070680
   8151c:	00080a71 	.word	0x00080a71

00081520 <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	return Is_udd_endpoint_stall_requested(ep_index);
   81520:	f000 000f 	and.w	r0, r0, #15
   81524:	4b02      	ldr	r3, [pc, #8]	; (81530 <udd_ep_is_halted+0x10>)
   81526:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
   8152a:	f3c0 40c0 	ubfx	r0, r0, #19, #1
   8152e:	4770      	bx	lr
   81530:	400ac1c0 	.word	0x400ac1c0

00081534 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   81534:	f000 030f 	and.w	r3, r0, #15
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	irqflags_t flags;

	if (USB_DEVICE_MAX_EP < ep_index) {
   81538:	2b01      	cmp	r3, #1
   8153a:	d857      	bhi.n	815ec <udd_ep_set_halt+0xb8>
		return false;
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
   8153c:	4a32      	ldr	r2, [pc, #200]	; (81608 <udd_ep_set_halt+0xd4>)
   8153e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   81542:	f412 2f00 	tst.w	r2, #524288	; 0x80000
   81546:	d153      	bne.n	815f0 <udd_ep_set_halt+0xbc>
	return Is_udd_endpoint_stall_requested(ep_index);
}


bool udd_ep_set_halt(udd_ep_id_t ep)
{
   81548:	b430      	push	{r4, r5}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   8154a:	1e59      	subs	r1, r3, #1
	if (USB_DEVICE_MAX_EP < ep_index) {
		return false;
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
			|| ptr_job->stall_requested) { // Endpoint stall is requested
   8154c:	eb01 0441 	add.w	r4, r1, r1, lsl #1
   81550:	4a2e      	ldr	r2, [pc, #184]	; (8160c <udd_ep_set_halt+0xd8>)
   81552:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
   81556:	7d12      	ldrb	r2, [r2, #20]
   81558:	f012 0f04 	tst.w	r2, #4
   8155c:	d14a      	bne.n	815f4 <udd_ep_set_halt+0xc0>
		return true; // Already STALL
	}

	if (ptr_job->busy == true) {
   8155e:	f012 0f01 	tst.w	r2, #1
   81562:	d149      	bne.n	815f8 <udd_ep_set_halt+0xc4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   81564:	f3ef 8210 	mrs	r2, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   81568:	fab2 f282 	clz	r2, r2
   8156c:	0952      	lsrs	r2, r2, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   8156e:	b672      	cpsid	i
   81570:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   81574:	2500      	movs	r5, #0
   81576:	4c26      	ldr	r4, [pc, #152]	; (81610 <udd_ep_set_halt+0xdc>)
   81578:	7025      	strb	r5, [r4, #0]
		return false; // Job on going, stall impossible
	}

	flags = cpu_irq_save();
	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(ep_index))) {
   8157a:	f010 0f80 	tst.w	r0, #128	; 0x80
   8157e:	d01d      	beq.n	815bc <udd_ep_set_halt+0x88>
   81580:	4824      	ldr	r0, [pc, #144]	; (81614 <udd_ep_set_halt+0xe0>)
   81582:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
   81586:	f410 5f40 	tst.w	r0, #12288	; 0x3000
   8158a:	d017      	beq.n	815bc <udd_ep_set_halt+0x88>
		// Delay the stall after the end of IN transfer on USB line
		ptr_job->stall_requested = true;
   8158c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   81590:	481e      	ldr	r0, [pc, #120]	; (8160c <udd_ep_set_halt+0xd8>)
   81592:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
   81596:	7d08      	ldrb	r0, [r1, #20]
   81598:	f040 0004 	orr.w	r0, r0, #4
   8159c:	7508      	strb	r0, [r1, #20]
#ifdef UDD_EP_FIFO_SUPPORTED
		udd_disable_in_send_interrupt(ep_index);
		udd_enable_endpoint_bank_autoswitch(ep_index);
#endif
		udd_enable_bank_interrupt(ep_index);
   8159e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   815a2:	481d      	ldr	r0, [pc, #116]	; (81618 <udd_ep_set_halt+0xe4>)
   815a4:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
		udd_enable_endpoint_interrupt(ep_index);
   815a8:	4099      	lsls	r1, r3
   815aa:	4b1c      	ldr	r3, [pc, #112]	; (8161c <udd_ep_set_halt+0xe8>)
   815ac:	6199      	str	r1, [r3, #24]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   815ae:	b32a      	cbz	r2, 815fc <udd_ep_set_halt+0xc8>
		cpu_irq_enable();
   815b0:	2001      	movs	r0, #1
   815b2:	7020      	strb	r0, [r4, #0]
   815b4:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   815b8:	b662      	cpsie	i
   815ba:	e022      	b.n	81602 <udd_ep_set_halt+0xce>
		cpu_irq_restore(flags);
		return true;
	}
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(ep_index);
   815bc:	4818      	ldr	r0, [pc, #96]	; (81620 <udd_ep_set_halt+0xec>)
   815be:	f850 1023 	ldr.w	r1, [r0, r3, lsl #2]
   815c2:	f421 7100 	bic.w	r1, r1, #512	; 0x200
   815c6:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	udd_ack_stall(ep_index);
   815ca:	2040      	movs	r0, #64	; 0x40
   815cc:	4915      	ldr	r1, [pc, #84]	; (81624 <udd_ep_set_halt+0xf0>)
   815ce:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	udd_enable_stall_handshake(ep_index);
   815d2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   815d6:	3190      	adds	r1, #144	; 0x90
   815d8:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   815dc:	b182      	cbz	r2, 81600 <udd_ep_set_halt+0xcc>
		cpu_irq_enable();
   815de:	2001      	movs	r0, #1
   815e0:	4b0b      	ldr	r3, [pc, #44]	; (81610 <udd_ep_set_halt+0xdc>)
   815e2:	7018      	strb	r0, [r3, #0]
   815e4:	f3bf 8f5f 	dmb	sy
   815e8:	b662      	cpsie	i
   815ea:	e00a      	b.n	81602 <udd_ep_set_halt+0xce>
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	irqflags_t flags;

	if (USB_DEVICE_MAX_EP < ep_index) {
		return false;
   815ec:	2000      	movs	r0, #0
	udd_disable_endpoint_bank_autoswitch(ep_index);
	udd_ack_stall(ep_index);
	udd_enable_stall_handshake(ep_index);
	cpu_irq_restore(flags);
	return true;
}
   815ee:	4770      	bx	lr
		return false;
	}

	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
			|| ptr_job->stall_requested) { // Endpoint stall is requested
		return true; // Already STALL
   815f0:	2001      	movs	r0, #1
   815f2:	4770      	bx	lr
   815f4:	2001      	movs	r0, #1
   815f6:	e004      	b.n	81602 <udd_ep_set_halt+0xce>
	}

	if (ptr_job->busy == true) {
		return false; // Job on going, stall impossible
   815f8:	2000      	movs	r0, #0
   815fa:	e002      	b.n	81602 <udd_ep_set_halt+0xce>
		udd_enable_endpoint_bank_autoswitch(ep_index);
#endif
		udd_enable_bank_interrupt(ep_index);
		udd_enable_endpoint_interrupt(ep_index);
		cpu_irq_restore(flags);
		return true;
   815fc:	2001      	movs	r0, #1
   815fe:	e000      	b.n	81602 <udd_ep_set_halt+0xce>
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(ep_index);
	udd_ack_stall(ep_index);
	udd_enable_stall_handshake(ep_index);
	cpu_irq_restore(flags);
	return true;
   81600:	2001      	movs	r0, #1
}
   81602:	bc30      	pop	{r4, r5}
   81604:	4770      	bx	lr
   81606:	bf00      	nop
   81608:	400ac1c0 	.word	0x400ac1c0
   8160c:	20070680 	.word	0x20070680
   81610:	20070206 	.word	0x20070206
   81614:	400ac130 	.word	0x400ac130
   81618:	400ac1f0 	.word	0x400ac1f0
   8161c:	400ac000 	.word	0x400ac000
   81620:	400ac100 	.word	0x400ac100
   81624:	400ac160 	.word	0x400ac160

00081628 <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
   81628:	b510      	push	{r4, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   8162a:	f000 000f 	and.w	r0, r0, #15
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
   8162e:	2801      	cmp	r0, #1
   81630:	d84e      	bhi.n	816d0 <udd_ep_clear_halt+0xa8>


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   81632:	1e43      	subs	r3, r0, #1
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
		return false;

	if (ptr_job->stall_requested) {
   81634:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   81638:	4a2c      	ldr	r2, [pc, #176]	; (816ec <udd_ep_clear_halt+0xc4>)
   8163a:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   8163e:	7d12      	ldrb	r2, [r2, #20]
   81640:	f012 0f04 	tst.w	r2, #4
   81644:	d048      	beq.n	816d8 <udd_ep_clear_halt+0xb0>
		// Endpoint stall has been requested but not done
		// Remove stall request
		ptr_job->stall_requested = false;
   81646:	460a      	mov	r2, r1
   81648:	4928      	ldr	r1, [pc, #160]	; (816ec <udd_ep_clear_halt+0xc4>)
   8164a:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   8164e:	7d11      	ldrb	r1, [r2, #20]
   81650:	f36f 0182 	bfc	r1, #2, #1
   81654:	7511      	strb	r1, [r2, #20]
		udd_disable_bank_interrupt(ep_index);
   81656:	0082      	lsls	r2, r0, #2
   81658:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   8165c:	4c24      	ldr	r4, [pc, #144]	; (816f0 <udd_ep_clear_halt+0xc8>)
   8165e:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
		udd_disable_endpoint_interrupt(ep_index);
   81662:	4081      	lsls	r1, r0
   81664:	f5a4 7408 	sub.w	r4, r4, #544	; 0x220
   81668:	6161      	str	r1, [r4, #20]
		b_stall_cleared = true;
	}
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   8166a:	4922      	ldr	r1, [pc, #136]	; (816f4 <udd_ep_clear_halt+0xcc>)
   8166c:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   81670:	f411 2f00 	tst.w	r1, #524288	; 0x80000
   81674:	d014      	beq.n	816a0 <udd_ep_clear_halt+0x78>
		if (Is_udd_stall(ep_index)) {
   81676:	4920      	ldr	r1, [pc, #128]	; (816f8 <udd_ep_clear_halt+0xd0>)
   81678:	5851      	ldr	r1, [r2, r1]
   8167a:	f011 0f40 	tst.w	r1, #64	; 0x40
   8167e:	d006      	beq.n	8168e <udd_ep_clear_halt+0x66>
			udd_ack_stall(ep_index);
   81680:	2040      	movs	r0, #64	; 0x40
   81682:	491e      	ldr	r1, [pc, #120]	; (816fc <udd_ep_clear_halt+0xd4>)
   81684:	5050      	str	r0, [r2, r1]
			// A packet has been stalled
			// then reset datatoggle
			udd_reset_data_toggle(ep_index);
   81686:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   8168a:	3190      	adds	r1, #144	; 0x90
   8168c:	5050      	str	r0, [r2, r1]
		}
		// Disable stall
		udd_disable_stall_handshake(ep_index);
   8168e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   81692:	4917      	ldr	r1, [pc, #92]	; (816f0 <udd_ep_clear_halt+0xc8>)
   81694:	5050      	str	r0, [r2, r1]
		udd_enable_endpoint_bank_autoswitch(ep_index);
   81696:	481a      	ldr	r0, [pc, #104]	; (81700 <udd_ep_clear_halt+0xd8>)
   81698:	5811      	ldr	r1, [r2, r0]
   8169a:	f441 7100 	orr.w	r1, r1, #512	; 0x200
   8169e:	5011      	str	r1, [r2, r0]
		b_stall_cleared = true;
	}
	if (b_stall_cleared) {
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
   816a0:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   816a4:	4911      	ldr	r1, [pc, #68]	; (816ec <udd_ep_clear_halt+0xc4>)
   816a6:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   816aa:	7d12      	ldrb	r2, [r2, #20]
   816ac:	f012 0f01 	tst.w	r2, #1
   816b0:	d010      	beq.n	816d4 <udd_ep_clear_halt+0xac>
			ptr_job->busy = false;
   816b2:	4608      	mov	r0, r1
   816b4:	0059      	lsls	r1, r3, #1
   816b6:	18ca      	adds	r2, r1, r3
   816b8:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
   816bc:	7d14      	ldrb	r4, [r2, #20]
   816be:	f36f 0400 	bfc	r4, #0, #1
   816c2:	7514      	strb	r4, [r2, #20]
			ptr_job->call_nohalt();
   816c4:	440b      	add	r3, r1
   816c6:	f850 3033 	ldr.w	r3, [r0, r3, lsl #3]
   816ca:	4798      	blx	r3
		}
	}
	return true;
   816cc:	2001      	movs	r0, #1
   816ce:	bd10      	pop	{r4, pc}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
	bool b_stall_cleared = false;

	if (USB_DEVICE_MAX_EP < ep_index)
		return false;
   816d0:	2000      	movs	r0, #0
   816d2:	bd10      	pop	{r4, pc}
		if (ptr_job->busy == true) {
			ptr_job->busy = false;
			ptr_job->call_nohalt();
		}
	}
	return true;
   816d4:	2001      	movs	r0, #1
   816d6:	bd10      	pop	{r4, pc}
		ptr_job->stall_requested = false;
		udd_disable_bank_interrupt(ep_index);
		udd_disable_endpoint_interrupt(ep_index);
		b_stall_cleared = true;
	}
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   816d8:	0082      	lsls	r2, r0, #2
   816da:	4906      	ldr	r1, [pc, #24]	; (816f4 <udd_ep_clear_halt+0xcc>)
   816dc:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   816e0:	f411 2f00 	tst.w	r1, #524288	; 0x80000
   816e4:	d1c7      	bne.n	81676 <udd_ep_clear_halt+0x4e>
		if (ptr_job->busy == true) {
			ptr_job->busy = false;
			ptr_job->call_nohalt();
		}
	}
	return true;
   816e6:	2001      	movs	r0, #1
}
   816e8:	bd10      	pop	{r4, pc}
   816ea:	bf00      	nop
   816ec:	20070680 	.word	0x20070680
   816f0:	400ac220 	.word	0x400ac220
   816f4:	400ac1c0 	.word	0x400ac1c0
   816f8:	400ac130 	.word	0x400ac130
   816fc:	400ac160 	.word	0x400ac160
   81700:	400ac100 	.word	0x400ac100

00081704 <udd_ep_run>:
	bool b_dir_in = Is_udd_endpoint_in(ep & USB_EP_ADDR_MASK);
#endif
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
   81704:	f000 000f 	and.w	r0, r0, #15
	if (USB_DEVICE_MAX_EP < ep) {
   81708:	2801      	cmp	r0, #1
   8170a:	d863      	bhi.n	817d4 <udd_ep_run+0xd0>


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
   8170c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
   8170e:	4c36      	ldr	r4, [pc, #216]	; (817e8 <udd_ep_run+0xe4>)
   81710:	69e5      	ldr	r5, [r4, #28]
   81712:	2401      	movs	r4, #1
   81714:	4084      	lsls	r4, r0
   81716:	422c      	tst	r4, r5
   81718:	d05e      	beq.n	817d8 <udd_ep_run+0xd4>
			|| Is_udd_endpoint_stall_requested(ep)
   8171a:	4c34      	ldr	r4, [pc, #208]	; (817ec <udd_ep_run+0xe8>)
   8171c:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
   81720:	f414 2f00 	tst.w	r4, #524288	; 0x80000
   81724:	d15a      	bne.n	817dc <udd_ep_run+0xd8>
	if (USB_DEVICE_MAX_EP < ep) {
		return false;
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
   81726:	1e44      	subs	r4, r0, #1

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
   81728:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   8172c:	4d30      	ldr	r5, [pc, #192]	; (817f0 <udd_ep_run+0xec>)
   8172e:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
   81732:	7d2d      	ldrb	r5, [r5, #20]
   81734:	f015 0f04 	tst.w	r5, #4
   81738:	d152      	bne.n	817e0 <udd_ep_run+0xdc>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
   8173a:	f3ef 8510 	mrs	r5, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = cpu_irq_is_enabled();
   8173e:	fab5 f585 	clz	r5, r5
   81742:	096d      	lsrs	r5, r5, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
   81744:	b672      	cpsid	i
   81746:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   8174a:	2700      	movs	r7, #0
   8174c:	4e29      	ldr	r6, [pc, #164]	; (817f4 <udd_ep_run+0xf0>)
   8174e:	7037      	strb	r7, [r6, #0]
		return false; // Endpoint is halted
	}

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
   81750:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   81754:	4f26      	ldr	r7, [pc, #152]	; (817f0 <udd_ep_run+0xec>)
   81756:	eb07 06c6 	add.w	r6, r7, r6, lsl #3
   8175a:	7d36      	ldrb	r6, [r6, #20]
   8175c:	f016 0f01 	tst.w	r6, #1
   81760:	d009      	beq.n	81776 <udd_ep_run+0x72>
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81762:	2d00      	cmp	r5, #0
   81764:	d03e      	beq.n	817e4 <udd_ep_run+0xe0>
		cpu_irq_enable();
   81766:	2201      	movs	r2, #1
   81768:	4b22      	ldr	r3, [pc, #136]	; (817f4 <udd_ep_run+0xf0>)
   8176a:	701a      	strb	r2, [r3, #0]
   8176c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
   81770:	b662      	cpsie	i
		cpu_irq_restore(flags);
		return false; // Job already on going
   81772:	2000      	movs	r0, #0
   81774:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	ptr_job->busy = true;
   81776:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   8177a:	4f1d      	ldr	r7, [pc, #116]	; (817f0 <udd_ep_run+0xec>)
   8177c:	eb07 06c6 	add.w	r6, r7, r6, lsl #3
   81780:	7d37      	ldrb	r7, [r6, #20]
   81782:	f047 0701 	orr.w	r7, r7, #1
   81786:	7537      	strb	r7, [r6, #20]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81788:	b12d      	cbz	r5, 81796 <udd_ep_run+0x92>
		cpu_irq_enable();
   8178a:	2601      	movs	r6, #1
   8178c:	4d19      	ldr	r5, [pc, #100]	; (817f4 <udd_ep_run+0xf0>)
   8178e:	702e      	strb	r6, [r5, #0]
   81790:	f3bf 8f5f 	dmb	sy
   81794:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// No job running. Let's setup a new one.
	ptr_job->buf = buf;
   81796:	4f16      	ldr	r7, [pc, #88]	; (817f0 <udd_ep_run+0xec>)
   81798:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   8179c:	00ed      	lsls	r5, r5, #3
   8179e:	197e      	adds	r6, r7, r5
   817a0:	6072      	str	r2, [r6, #4]
	ptr_job->buf_size = buf_size;
   817a2:	60b3      	str	r3, [r6, #8]
	ptr_job->buf_cnt = 0;
   817a4:	2200      	movs	r2, #0
   817a6:	60f2      	str	r2, [r6, #12]
	ptr_job->buf_load = 0;
   817a8:	6132      	str	r2, [r6, #16]
	ptr_job->call_trans = callback;
   817aa:	9a06      	ldr	r2, [sp, #24]
   817ac:	517a      	str	r2, [r7, r5]
	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
   817ae:	b919      	cbnz	r1, 817b8 <udd_ep_run+0xb4>
   817b0:	fab3 f383 	clz	r3, r3
   817b4:	095b      	lsrs	r3, r3, #5
   817b6:	e000      	b.n	817ba <udd_ep_run+0xb6>
   817b8:	2301      	movs	r3, #1
   817ba:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   817be:	4a0c      	ldr	r2, [pc, #48]	; (817f0 <udd_ep_run+0xec>)
   817c0:	eb02 04c4 	add.w	r4, r2, r4, lsl #3
   817c4:	7d22      	ldrb	r2, [r4, #20]
   817c6:	f363 0241 	bfi	r2, r3, #1, #1
   817ca:	7522      	strb	r2, [r4, #20]
#endif // UDD_EP_FIFO_SUPPORTED

#ifdef UDD_EP_DMA_SUPPORTED
	// Request first DMA transfer
	dbg_print("(exDMA%x) ", ep);
	udd_ep_trans_done(ep);
   817cc:	4b0a      	ldr	r3, [pc, #40]	; (817f8 <udd_ep_run+0xf4>)
   817ce:	4798      	blx	r3
	return true;
   817d0:	2001      	movs	r0, #1
   817d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
	if (USB_DEVICE_MAX_EP < ep) {
		return false;
   817d4:	2000      	movs	r0, #0
	// Request first DMA transfer
	dbg_print("(exDMA%x) ", ep);
	udd_ep_trans_done(ep);
	return true;
#endif
}
   817d6:	4770      	bx	lr
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
		return false; // Endpoint is halted
   817d8:	2000      	movs	r0, #0
   817da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   817dc:	2000      	movs	r0, #0
   817de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   817e0:	2000      	movs	r0, #0
   817e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	flags = cpu_irq_save();
	if (ptr_job->busy == true) {
		cpu_irq_restore(flags);
		return false; // Job already on going
   817e4:	2000      	movs	r0, #0
	// Request first DMA transfer
	dbg_print("(exDMA%x) ", ep);
	udd_ep_trans_done(ep);
	return true;
#endif
}
   817e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   817e8:	400ac000 	.word	0x400ac000
   817ec:	400ac1c0 	.word	0x400ac1c0
   817f0:	20070680 	.word	0x20070680
   817f4:	20070206 	.word	0x20070206
   817f8:	00080aa5 	.word	0x00080aa5

000817fc <udd_ep_alloc>:


#if (0 != USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
   817fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   81800:	b082      	sub	sp, #8
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t nb_bank, bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;
   81802:	f000 040f 	and.w	r4, r0, #15

	if (ep > USB_DEVICE_MAX_EP) {
   81806:	2c01      	cmp	r4, #1
   81808:	f200 80e1 	bhi.w	819ce <udd_ep_alloc+0x1d2>
		return false;
	}
	if (Is_udd_endpoint_enabled(ep)) {
   8180c:	4b79      	ldr	r3, [pc, #484]	; (819f4 <udd_ep_alloc+0x1f8>)
   8180e:	69db      	ldr	r3, [r3, #28]
   81810:	4627      	mov	r7, r4
   81812:	2501      	movs	r5, #1
   81814:	40a5      	lsls	r5, r4
   81816:	401d      	ands	r5, r3
   81818:	f040 80db 	bne.w	819d2 <udd_ep_alloc+0x1d6>
		return false;
	}
	dbg_print("alloc(%x, %d) ", ep, MaxEndpointSize);

	// Bank choise
	switch (bmAttributes & USB_EP_TYPE_MASK) {
   8181c:	f011 0303 	ands.w	r3, r1, #3
   81820:	f000 80d9 	beq.w	819d6 <udd_ep_alloc+0x1da>
   81824:	2b02      	cmp	r3, #2
   81826:	d905      	bls.n	81834 <udd_ep_alloc+0x38>
   81828:	2b03      	cmp	r3, #3
   8182a:	f040 80d4 	bne.w	819d6 <udd_ep_alloc+0x1da>
		Assert(false);
		return false;
	}
	switch (nb_bank) {
	case 1:
		bank = UOTGHS_DEVEPTCFG_EPBK_1_BANK >>
   8182e:	f04f 0800 	mov.w	r8, #0
   81832:	e001      	b.n	81838 <udd_ep_alloc+0x3c>
				UOTGHS_DEVEPTCFG_EPBK_Pos;
		break;
	case 2:
		bank = UOTGHS_DEVEPTCFG_EPBK_2_BANK >>
   81834:	f04f 0801 	mov.w	r8, #1
	Assert((MaxEndpointSize == 1023)
		|| !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);

	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
   81838:	ea4f 0c84 	mov.w	ip, r4, lsl #2
   8183c:	f8df e1bc 	ldr.w	lr, [pc, #444]	; 819fc <udd_ep_alloc+0x200>
   81840:	f85e 6024 	ldr.w	r6, [lr, r4, lsl #2]
   81844:	f426 56cb 	bic.w	r6, r6, #6496	; 0x1960
   81848:	f026 061c 	bic.w	r6, r6, #28
   8184c:	02c9      	lsls	r1, r1, #11
   8184e:	f401 51c0 	and.w	r1, r1, #6144	; 0x1800
   81852:	f000 0080 	and.w	r0, r0, #128	; 0x80
   81856:	2800      	cmp	r0, #0
   81858:	bf18      	it	ne
   8185a:	f44f 7580 	movne.w	r5, #256	; 0x100
   8185e:	f5a2 6380 	sub.w	r3, r2, #1024	; 0x400
   81862:	b29b      	uxth	r3, r3
   81864:	f5b3 4f7c 	cmp.w	r3, #64512	; 0xfc00
   81868:	d304      	bcc.n	81874 <udd_ep_alloc+0x78>
   8186a:	2a08      	cmp	r2, #8
   8186c:	d905      	bls.n	8187a <udd_ep_alloc+0x7e>
   8186e:	0053      	lsls	r3, r2, #1
   81870:	3b01      	subs	r3, #1
   81872:	e003      	b.n	8187c <udd_ep_alloc+0x80>
   81874:	f240 73ff 	movw	r3, #2047	; 0x7ff
   81878:	e000      	b.n	8187c <udd_ep_alloc+0x80>
   8187a:	230f      	movs	r3, #15
   8187c:	fab3 f383 	clz	r3, r3
   81880:	ea41 0888 	orr.w	r8, r1, r8, lsl #2
   81884:	ea48 0505 	orr.w	r5, r8, r5
   81888:	f1c3 031c 	rsb	r3, r3, #28
   8188c:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
   81890:	f423 63d0 	bic.w	r3, r3, #1664	; 0x680
   81894:	f023 0303 	bic.w	r3, r3, #3
   81898:	04db      	lsls	r3, r3, #19
   8189a:	0cdb      	lsrs	r3, r3, #19
   8189c:	4333      	orrs	r3, r6
   8189e:	f84c 300e 	str.w	r3, [ip, lr]
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
   818a2:	2601      	movs	r6, #1
   818a4:	fa06 f207 	lsl.w	r2, r6, r7
   818a8:	b296      	uxth	r6, r2

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
   818aa:	2c00      	cmp	r4, #0
   818ac:	f040 8099 	bne.w	819e2 <udd_ep_alloc+0x1e6>
		if (Is_udd_endpoint_enabled(i)) {
   818b0:	4b50      	ldr	r3, [pc, #320]	; (819f4 <udd_ep_alloc+0x1f8>)
   818b2:	69db      	ldr	r3, [r3, #28]
   818b4:	f013 0f02 	tst.w	r3, #2
   818b8:	f000 8093 	beq.w	819e2 <udd_ep_alloc+0x1e6>
			ep_allocated |= 1 << i;
   818bc:	f042 0602 	orr.w	r6, r2, #2
   818c0:	b2b6      	uxth	r6, r6
			udd_disable_endpoint(i);
   818c2:	4a4c      	ldr	r2, [pc, #304]	; (819f4 <udd_ep_alloc+0x1f8>)
   818c4:	69d3      	ldr	r3, [r2, #28]
   818c6:	f023 0302 	bic.w	r3, r3, #2
   818ca:	61d3      	str	r3, [r2, #28]
			udd_unallocate_memory(i);
   818cc:	f502 7282 	add.w	r2, r2, #260	; 0x104
   818d0:	6813      	ldr	r3, [r2, #0]
   818d2:	f023 0302 	bic.w	r3, r3, #2
   818d6:	6013      	str	r3, [r2, #0]
   818d8:	e083      	b.n	819e2 <udd_ep_alloc+0x1e6>
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
   818da:	fa46 f304 	asr.w	r3, r6, r4
   818de:	f013 0f01 	tst.w	r3, #1
   818e2:	d06e      	beq.n	819c2 <udd_ep_alloc+0x1c6>
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
   818e4:	f104 3eff 	add.w	lr, r4, #4294967295
			bool b_restart = ptr_job->busy;
   818e8:	eb0e 034e 	add.w	r3, lr, lr, lsl #1
   818ec:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
   818f0:	7d1a      	ldrb	r2, [r3, #20]
   818f2:	f002 0101 	and.w	r1, r2, #1
			// Restart running job because
			// memory window slides up and its data is lost
			ptr_job->busy = false;
   818f6:	f36f 0200 	bfc	r2, #0, #1
   818fa:	751a      	strb	r2, [r3, #20]
			// Re-allocate memory
			udd_allocate_memory(i);
   818fc:	00a0      	lsls	r0, r4, #2
   818fe:	eb00 0c05 	add.w	ip, r0, r5
   81902:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   81906:	f043 0302 	orr.w	r3, r3, #2
   8190a:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
			udd_enable_endpoint(i);
   8190e:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 819f4 <udd_ep_alloc+0x1f8>
   81912:	f8d9 201c 	ldr.w	r2, [r9, #28]
   81916:	2301      	movs	r3, #1
   81918:	40a3      	lsls	r3, r4
   8191a:	4313      	orrs	r3, r2
   8191c:	f8c9 301c 	str.w	r3, [r9, #28]
			if (!Is_udd_endpoint_configured(i)) {
   81920:	f858 3024 	ldr.w	r3, [r8, r4, lsl #2]
   81924:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   81928:	d119      	bne.n	8195e <udd_ep_alloc+0x162>
				dbg_print("ErrRealloc%d ", i);
				if (NULL == ptr_job->call_trans) {
   8192a:	eb0e 034e 	add.w	r3, lr, lr, lsl #1
   8192e:	4a32      	ldr	r2, [pc, #200]	; (819f8 <udd_ep_alloc+0x1fc>)
   81930:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
   81934:	2d00      	cmp	r5, #0
   81936:	d050      	beq.n	819da <udd_ep_alloc+0x1de>
					return false;
				}
				if (Is_udd_endpoint_in(i)) {
   81938:	f8dc 3000 	ldr.w	r3, [ip]
   8193c:	f413 7f80 	tst.w	r3, #256	; 0x100
					i |= USB_EP_DIR_IN;
   81940:	bf18      	it	ne
   81942:	f044 0480 	orrne.w	r4, r4, #128	; 0x80
				}
				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
   81946:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
   8194a:	4b2b      	ldr	r3, [pc, #172]	; (819f8 <udd_ep_alloc+0x1fc>)
   8194c:	eb03 0ece 	add.w	lr, r3, lr, lsl #3
   81950:	2001      	movs	r0, #1
   81952:	f8de 100c 	ldr.w	r1, [lr, #12]
   81956:	4622      	mov	r2, r4
   81958:	47a8      	blx	r5
						ptr_job->buf_cnt, i);
				return false;
   8195a:	2000      	movs	r0, #0
   8195c:	e046      	b.n	819ec <udd_ep_alloc+0x1f0>
			}
			udd_enable_endpoint_bank_autoswitch(i);
   8195e:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
   81962:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   81966:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
			if (b_restart) {
   8196a:	b351      	cbz	r1, 819c2 <udd_ep_alloc+0x1c6>
				if (!Is_udd_endpoint_dma_supported(i)
					&& !Is_udd_endpoint_in(i)) {
					ptr_job->buf_cnt -= ptr_job->buf_load;
				}
#  else
				ptr_job->buf_cnt -= ptr_job->buf_load;
   8196c:	eb0e 024e 	add.w	r2, lr, lr, lsl #1
   81970:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
   81974:	f102 0108 	add.w	r1, r2, #8
   81978:	68d3      	ldr	r3, [r2, #12]
   8197a:	6912      	ldr	r2, [r2, #16]
   8197c:	1a9b      	subs	r3, r3, r2
   8197e:	604b      	str	r3, [r1, #4]
#  endif
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   81980:	5942      	ldr	r2, [r0, r5]
   81982:	f412 7f80 	tst.w	r2, #256	; 0x100
   81986:	bf14      	ite	ne
   81988:	f044 0a80 	orrne.w	sl, r4, #128	; 0x80
   8198c:	46a2      	moveq	sl, r4
							(i | USB_EP_DIR_IN) : i,
						ptr_job->b_shortpacket,
   8198e:	ea4f 094e 	mov.w	r9, lr, lsl #1
   81992:	eb09 0c0e 	add.w	ip, r9, lr
   81996:	eb07 0ccc 	add.w	ip, r7, ip, lsl #3
   8199a:	f89c 1014 	ldrb.w	r1, [ip, #20]
					ptr_job->buf_cnt -= ptr_job->buf_load;
				}
#  else
				ptr_job->buf_cnt -= ptr_job->buf_load;
#  endif
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   8199e:	f8dc 2004 	ldr.w	r2, [ip, #4]
   819a2:	f8dc c008 	ldr.w	ip, [ip, #8]
   819a6:	44ce      	add	lr, r9
   819a8:	f857 003e 	ldr.w	r0, [r7, lr, lsl #3]
   819ac:	9000      	str	r0, [sp, #0]
   819ae:	4650      	mov	r0, sl
   819b0:	f3c1 0140 	ubfx	r1, r1, #1, #1
   819b4:	441a      	add	r2, r3
   819b6:	ebc3 030c 	rsb	r3, r3, ip
   819ba:	f8df c044 	ldr.w	ip, [pc, #68]	; 81a00 <udd_ep_alloc+0x204>
   819be:	47e0      	blx	ip
						ptr_job->b_shortpacket,
						&ptr_job->buf[ptr_job->buf_cnt],
						ptr_job->buf_size
							- ptr_job->buf_cnt,
						ptr_job->call_trans);
				if (!b_restart) {
   819c0:	b168      	cbz	r0, 819de <udd_ep_alloc+0x1e2>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
   819c2:	3401      	adds	r4, #1
   819c4:	b2e4      	uxtb	r4, r4
   819c6:	2c01      	cmp	r4, #1
   819c8:	d987      	bls.n	818da <udd_ep_alloc+0xde>
					return false;
				}
			}
		}
	}
	return true;
   819ca:	2001      	movs	r0, #1
   819cc:	e00e      	b.n	819ec <udd_ep_alloc+0x1f0>

	b_dir_in = ep & USB_EP_DIR_IN;
	ep = ep & USB_EP_ADDR_MASK;

	if (ep > USB_DEVICE_MAX_EP) {
		return false;
   819ce:	2000      	movs	r0, #0
   819d0:	e00c      	b.n	819ec <udd_ep_alloc+0x1f0>
	}
	if (Is_udd_endpoint_enabled(ep)) {
		return false;
   819d2:	2000      	movs	r0, #0
   819d4:	e00a      	b.n	819ec <udd_ep_alloc+0x1f0>
	case USB_EP_TYPE_BULK:
		nb_bank = UDD_BULK_NB_BANK(ep);
		break;
	default:
		Assert(false);
		return false;
   819d6:	2000      	movs	r0, #0
   819d8:	e008      	b.n	819ec <udd_ep_alloc+0x1f0>
			udd_allocate_memory(i);
			udd_enable_endpoint(i);
			if (!Is_udd_endpoint_configured(i)) {
				dbg_print("ErrRealloc%d ", i);
				if (NULL == ptr_job->call_trans) {
					return false;
   819da:	2000      	movs	r0, #0
   819dc:	e006      	b.n	819ec <udd_ep_alloc+0x1f0>
						ptr_job->buf_size
							- ptr_job->buf_cnt,
						ptr_job->call_trans);
				if (!b_restart) {
					dbg_print("ErrReRun%d ", i);
					return false;
   819de:	2000      	movs	r0, #0
   819e0:	e004      	b.n	819ec <udd_ep_alloc+0x1f0>

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
		if (ep_allocated & (1 << i)) {
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
			bool b_restart = ptr_job->busy;
   819e2:	4f05      	ldr	r7, [pc, #20]	; (819f8 <udd_ep_alloc+0x1fc>)
			// Restart running job because
			// memory window slides up and its data is lost
			ptr_job->busy = false;
			// Re-allocate memory
			udd_allocate_memory(i);
   819e4:	4d05      	ldr	r5, [pc, #20]	; (819fc <udd_ep_alloc+0x200>)
			udd_enable_endpoint(i);
			if (!Is_udd_endpoint_configured(i)) {
   819e6:	f8df 801c 	ldr.w	r8, [pc, #28]	; 81a04 <udd_ep_alloc+0x208>
   819ea:	e776      	b.n	818da <udd_ep_alloc+0xde>
				}
			}
		}
	}
	return true;
}
   819ec:	b002      	add	sp, #8
   819ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   819f2:	bf00      	nop
   819f4:	400ac000 	.word	0x400ac000
   819f8:	20070680 	.word	0x20070680
   819fc:	400ac100 	.word	0x400ac100
   81a00:	00081705 	.word	0x00081705
   81a04:	400ac130 	.word	0x400ac130

00081a08 <udd_ep_abort>:
#endif
}


void udd_ep_abort(udd_ep_id_t ep)
{
   81a08:	b570      	push	{r4, r5, r6, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   81a0a:	f000 020f 	and.w	r2, r0, #15
		udd_disable_in_send_interrupt(ep_index);
	} else
#endif
	{
		// Stop DMA transfer
		udd_disable_endpoint_dma_interrupt(ep_index);
   81a0e:	1e54      	subs	r4, r2, #1
   81a10:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   81a14:	40a3      	lsls	r3, r4
   81a16:	4915      	ldr	r1, [pc, #84]	; (81a6c <udd_ep_abort+0x64>)
   81a18:	614b      	str	r3, [r1, #20]
		udd_endpoint_dma_set_control(ep_index, 0);
   81a1a:	4b15      	ldr	r3, [pc, #84]	; (81a70 <udd_ep_abort+0x68>)
   81a1c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   81a20:	2500      	movs	r5, #0
   81a22:	609d      	str	r5, [r3, #8]
	}
	udd_disable_endpoint_interrupt(ep_index);
   81a24:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   81a28:	4093      	lsls	r3, r2
   81a2a:	614b      	str	r3, [r1, #20]
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
   81a2c:	f010 0f80 	tst.w	r0, #128	; 0x80
   81a30:	d013      	beq.n	81a5a <udd_ep_abort+0x52>
		while(udd_nb_busy_bank(ep_index)) {
   81a32:	0093      	lsls	r3, r2, #2
   81a34:	480f      	ldr	r0, [pc, #60]	; (81a74 <udd_ep_abort+0x6c>)
   81a36:	4418      	add	r0, r3
			udd_kill_last_in_bank(ep_index);
   81a38:	4d0f      	ldr	r5, [pc, #60]	; (81a78 <udd_ep_abort+0x70>)
   81a3a:	441d      	add	r5, r3
   81a3c:	f44f 5600 	mov.w	r6, #8192	; 0x2000
			while(Is_udd_kill_last(ep_index));
   81a40:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
   81a44:	4419      	add	r1, r3
   81a46:	e004      	b.n	81a52 <udd_ep_abort+0x4a>
	}
	udd_disable_endpoint_interrupt(ep_index);
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
		while(udd_nb_busy_bank(ep_index)) {
			udd_kill_last_in_bank(ep_index);
   81a48:	602e      	str	r6, [r5, #0]
			while(Is_udd_kill_last(ep_index));
   81a4a:	680b      	ldr	r3, [r1, #0]
   81a4c:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   81a50:	d1fb      	bne.n	81a4a <udd_ep_abort+0x42>
		udd_endpoint_dma_set_control(ep_index, 0);
	}
	udd_disable_endpoint_interrupt(ep_index);
	// Kill IN banks
	if (ep & USB_EP_DIR_IN) {
		while(udd_nb_busy_bank(ep_index)) {
   81a52:	6803      	ldr	r3, [r0, #0]
   81a54:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   81a58:	d1f6      	bne.n	81a48 <udd_ep_abort+0x40>
static void udd_ep_abort_job(udd_ep_id_t ep)
{
	ep &= USB_EP_ADDR_MASK;

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   81a5a:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   81a5e:	4807      	ldr	r0, [pc, #28]	; (81a7c <udd_ep_abort+0x74>)
   81a60:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   81a64:	2101      	movs	r1, #1
   81a66:	4b06      	ldr	r3, [pc, #24]	; (81a80 <udd_ep_abort+0x78>)
   81a68:	4798      	blx	r3
   81a6a:	bd70      	pop	{r4, r5, r6, pc}
   81a6c:	400ac000 	.word	0x400ac000
   81a70:	400ac300 	.word	0x400ac300
   81a74:	400ac130 	.word	0x400ac130
   81a78:	400ac1f0 	.word	0x400ac1f0
   81a7c:	20070680 	.word	0x20070680
   81a80:	00080a71 	.word	0x00080a71

00081a84 <udi_hid_setup>:
 * \retval true if the descriptor is supported
 */
static bool udi_hid_reqstdifaceget_descriptor(uint8_t *report_desc);

bool udi_hid_setup( uint8_t *rate, uint8_t *protocol, uint8_t *report_desc, bool (*setup_report)(void) )
{
   81a84:	b538      	push	{r3, r4, r5, lr}
   81a86:	4614      	mov	r4, r2
	if (Udd_setup_is_in()) {
   81a88:	4a37      	ldr	r2, [pc, #220]	; (81b68 <udi_hid_setup+0xe4>)
   81a8a:	7812      	ldrb	r2, [r2, #0]
   81a8c:	f012 0f80 	tst.w	r2, #128	; 0x80
   81a90:	d03f      	beq.n	81b12 <udi_hid_setup+0x8e>
		// Requests Interface GET
		if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   81a92:	f012 0260 	ands.w	r2, r2, #96	; 0x60
   81a96:	d126      	bne.n	81ae6 <udi_hid_setup+0x62>
			// Requests Standard Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
   81a98:	4d33      	ldr	r5, [pc, #204]	; (81b68 <udi_hid_setup+0xe4>)
   81a9a:	786d      	ldrb	r5, [r5, #1]
   81a9c:	2d06      	cmp	r5, #6
   81a9e:	d122      	bne.n	81ae6 <udi_hid_setup+0x62>
	usb_hid_descriptor_t UDC_DESC_STORAGE *ptr_hid_desc;

	// Get the USB descriptor which is located after the interface descriptor
	// This descriptor must be the HID descriptor
	ptr_hid_desc = (usb_hid_descriptor_t UDC_DESC_STORAGE *) ((uint8_t *)
			udc_get_interface_desc() + sizeof(usb_iface_desc_t));
   81aa0:	4b32      	ldr	r3, [pc, #200]	; (81b6c <udi_hid_setup+0xe8>)
   81aa2:	4798      	blx	r3
	if (USB_DT_HID != ptr_hid_desc->bDescriptorType)
   81aa4:	7a83      	ldrb	r3, [r0, #10]
   81aa6:	2b21      	cmp	r3, #33	; 0x21
   81aa8:	d14f      	bne.n	81b4a <udi_hid_setup+0xc6>

	// The SETUP request can ask for:
	// - an USB_DT_HID descriptor
	// - or USB_DT_HID_REPORT descriptor
	// - or USB_DT_HID_PHYSICAL descriptor
	if (USB_DT_HID == (uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
   81aaa:	4b2f      	ldr	r3, [pc, #188]	; (81b68 <udi_hid_setup+0xe4>)
   81aac:	885b      	ldrh	r3, [r3, #2]
   81aae:	0a1b      	lsrs	r3, r3, #8
   81ab0:	2b21      	cmp	r3, #33	; 0x21
   81ab2:	d10b      	bne.n	81acc <udi_hid_setup+0x48>
		// USB_DT_HID descriptor requested then send it
		udd_g_ctrlreq.payload = (uint8_t *) ptr_hid_desc;
   81ab4:	4b2c      	ldr	r3, [pc, #176]	; (81b68 <udi_hid_setup+0xe4>)
{
	usb_hid_descriptor_t UDC_DESC_STORAGE *ptr_hid_desc;

	// Get the USB descriptor which is located after the interface descriptor
	// This descriptor must be the HID descriptor
	ptr_hid_desc = (usb_hid_descriptor_t UDC_DESC_STORAGE *) ((uint8_t *)
   81ab6:	f100 0209 	add.w	r2, r0, #9
	// - an USB_DT_HID descriptor
	// - or USB_DT_HID_REPORT descriptor
	// - or USB_DT_HID_PHYSICAL descriptor
	if (USB_DT_HID == (uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
		// USB_DT_HID descriptor requested then send it
		udd_g_ctrlreq.payload = (uint8_t *) ptr_hid_desc;
   81aba:	609a      	str	r2, [r3, #8]
		udd_g_ctrlreq.payload_size =
				min(udd_g_ctrlreq.req.wLength,
   81abc:	7a41      	ldrb	r1, [r0, #9]
   81abe:	88da      	ldrh	r2, [r3, #6]
   81ac0:	428a      	cmp	r2, r1
   81ac2:	bf28      	it	cs
   81ac4:	460a      	movcs	r2, r1
	// - or USB_DT_HID_REPORT descriptor
	// - or USB_DT_HID_PHYSICAL descriptor
	if (USB_DT_HID == (uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
		// USB_DT_HID descriptor requested then send it
		udd_g_ctrlreq.payload = (uint8_t *) ptr_hid_desc;
		udd_g_ctrlreq.payload_size =
   81ac6:	819a      	strh	r2, [r3, #12]
				min(udd_g_ctrlreq.req.wLength,
				ptr_hid_desc->bLength);
		return true;
   81ac8:	2001      	movs	r0, #1
   81aca:	bd38      	pop	{r3, r4, r5, pc}
	}
	// The HID_X descriptor requested must correspond to report type
	// included in the HID descriptor
	if (ptr_hid_desc->bRDescriptorType ==
   81acc:	7bc2      	ldrb	r2, [r0, #15]
   81ace:	429a      	cmp	r2, r3
   81ad0:	d13d      	bne.n	81b4e <udi_hid_setup+0xca>
			(uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
		// Send HID Report descriptor given by high level
		udd_g_ctrlreq.payload = report_desc;
   81ad2:	4b25      	ldr	r3, [pc, #148]	; (81b68 <udi_hid_setup+0xe4>)
   81ad4:	609c      	str	r4, [r3, #8]
		udd_g_ctrlreq.payload_size =
				min(udd_g_ctrlreq.req.wLength,
   81ad6:	88d9      	ldrh	r1, [r3, #6]
   81ad8:	8a02      	ldrh	r2, [r0, #16]
   81ada:	428a      	cmp	r2, r1
   81adc:	bf28      	it	cs
   81ade:	460a      	movcs	r2, r1
	// included in the HID descriptor
	if (ptr_hid_desc->bRDescriptorType ==
			(uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
		// Send HID Report descriptor given by high level
		udd_g_ctrlreq.payload = report_desc;
		udd_g_ctrlreq.payload_size =
   81ae0:	819a      	strh	r2, [r3, #12]
				min(udd_g_ctrlreq.req.wLength,
				le16_to_cpu(ptr_hid_desc->wDescriptorLength));
		return true;
   81ae2:	2001      	movs	r0, #1
   81ae4:	bd38      	pop	{r3, r4, r5, pc}

			case USB_REQ_GET_DESCRIPTOR:
				return udi_hid_reqstdifaceget_descriptor(report_desc);
			}
		}
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   81ae6:	2a20      	cmp	r2, #32
   81ae8:	d133      	bne.n	81b52 <udi_hid_setup+0xce>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
   81aea:	4a1f      	ldr	r2, [pc, #124]	; (81b68 <udi_hid_setup+0xe4>)
   81aec:	7852      	ldrb	r2, [r2, #1]
   81aee:	2a02      	cmp	r2, #2
   81af0:	d005      	beq.n	81afe <udi_hid_setup+0x7a>
   81af2:	2a03      	cmp	r2, #3
   81af4:	d008      	beq.n	81b08 <udi_hid_setup+0x84>
   81af6:	2a01      	cmp	r2, #1
   81af8:	d12d      	bne.n	81b56 <udi_hid_setup+0xd2>

			case USB_REQ_HID_GET_REPORT:
				return setup_report();
   81afa:	4798      	blx	r3
   81afc:	bd38      	pop	{r3, r4, r5, pc}

			case USB_REQ_HID_GET_IDLE:
				udd_g_ctrlreq.payload = rate;
   81afe:	4b1a      	ldr	r3, [pc, #104]	; (81b68 <udi_hid_setup+0xe4>)
   81b00:	6098      	str	r0, [r3, #8]
				udd_g_ctrlreq.payload_size = 1;
   81b02:	2001      	movs	r0, #1
   81b04:	8198      	strh	r0, [r3, #12]
				return true;
   81b06:	bd38      	pop	{r3, r4, r5, pc}

			case USB_REQ_HID_GET_PROTOCOL:
				udd_g_ctrlreq.payload = protocol;
   81b08:	4b17      	ldr	r3, [pc, #92]	; (81b68 <udi_hid_setup+0xe4>)
   81b0a:	6099      	str	r1, [r3, #8]
				udd_g_ctrlreq.payload_size = 1;
   81b0c:	2001      	movs	r0, #1
   81b0e:	8198      	strh	r0, [r3, #12]
				return true;
   81b10:	bd38      	pop	{r3, r4, r5, pc}
			}
		}
	}
	if (Udd_setup_is_out()) {
		// Requests Interface SET
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   81b12:	f002 0260 	and.w	r2, r2, #96	; 0x60
   81b16:	2a20      	cmp	r2, #32
   81b18:	d11f      	bne.n	81b5a <udi_hid_setup+0xd6>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
   81b1a:	4a13      	ldr	r2, [pc, #76]	; (81b68 <udi_hid_setup+0xe4>)
   81b1c:	7852      	ldrb	r2, [r2, #1]
   81b1e:	2a0a      	cmp	r2, #10
   81b20:	d005      	beq.n	81b2e <udi_hid_setup+0xaa>
   81b22:	2a0b      	cmp	r2, #11
   81b24:	d009      	beq.n	81b3a <udi_hid_setup+0xb6>
   81b26:	2a09      	cmp	r2, #9
   81b28:	d119      	bne.n	81b5e <udi_hid_setup+0xda>

			case USB_REQ_HID_SET_REPORT:
				return setup_report();
   81b2a:	4798      	blx	r3
   81b2c:	bd38      	pop	{r3, r4, r5, pc}

			case USB_REQ_HID_SET_IDLE:
				*rate = udd_g_ctrlreq.req.wValue >> 8;
   81b2e:	4b0e      	ldr	r3, [pc, #56]	; (81b68 <udi_hid_setup+0xe4>)
   81b30:	885b      	ldrh	r3, [r3, #2]
   81b32:	0a1b      	lsrs	r3, r3, #8
   81b34:	7003      	strb	r3, [r0, #0]
				return true;
   81b36:	2001      	movs	r0, #1
   81b38:	bd38      	pop	{r3, r4, r5, pc}

			case USB_REQ_HID_SET_PROTOCOL:
				if (0 != udd_g_ctrlreq.req.wLength)
   81b3a:	4b0b      	ldr	r3, [pc, #44]	; (81b68 <udi_hid_setup+0xe4>)
   81b3c:	88db      	ldrh	r3, [r3, #6]
   81b3e:	b983      	cbnz	r3, 81b62 <udi_hid_setup+0xde>
					return false;
				*protocol = udd_g_ctrlreq.req.wValue;
   81b40:	4b09      	ldr	r3, [pc, #36]	; (81b68 <udi_hid_setup+0xe4>)
   81b42:	885b      	ldrh	r3, [r3, #2]
   81b44:	700b      	strb	r3, [r1, #0]
				return true;
   81b46:	2001      	movs	r0, #1
   81b48:	bd38      	pop	{r3, r4, r5, pc}
	// Get the USB descriptor which is located after the interface descriptor
	// This descriptor must be the HID descriptor
	ptr_hid_desc = (usb_hid_descriptor_t UDC_DESC_STORAGE *) ((uint8_t *)
			udc_get_interface_desc() + sizeof(usb_iface_desc_t));
	if (USB_DT_HID != ptr_hid_desc->bDescriptorType)
		return false;
   81b4a:	2000      	movs	r0, #0
   81b4c:	bd38      	pop	{r3, r4, r5, pc}
		udd_g_ctrlreq.payload_size =
				min(udd_g_ctrlreq.req.wLength,
				le16_to_cpu(ptr_hid_desc->wDescriptorLength));
		return true;
	}
	return false;
   81b4e:	2000      	movs	r0, #0
   81b50:	bd38      	pop	{r3, r4, r5, pc}
				*protocol = udd_g_ctrlreq.req.wValue;
				return true;
			}
		}
	}
	return false;	// Request not supported
   81b52:	2000      	movs	r0, #0
   81b54:	bd38      	pop	{r3, r4, r5, pc}
   81b56:	2000      	movs	r0, #0
   81b58:	bd38      	pop	{r3, r4, r5, pc}
   81b5a:	2000      	movs	r0, #0
   81b5c:	bd38      	pop	{r3, r4, r5, pc}
   81b5e:	2000      	movs	r0, #0
   81b60:	bd38      	pop	{r3, r4, r5, pc}
				*rate = udd_g_ctrlreq.req.wValue >> 8;
				return true;

			case USB_REQ_HID_SET_PROTOCOL:
				if (0 != udd_g_ctrlreq.req.wLength)
					return false;
   81b62:	2000      	movs	r0, #0
				return true;
			}
		}
	}
	return false;	// Request not supported
}
   81b64:	bd38      	pop	{r3, r4, r5, pc}
   81b66:	bf00      	nop
   81b68:	20070720 	.word	0x20070720
   81b6c:	00080379 	.word	0x00080379

00081b70 <sysclk_enable_usb>:
 *
 * \param pll_id Source of the USB clock.
 * \param div Actual clock divisor. Must be superior to 0.
 */
void sysclk_enable_usb(void)
{
   81b70:	b508      	push	{r3, lr}
	}
#endif

	if (CONFIG_USBCLK_SOURCE == USBCLK_SRC_UPLL) {

		pmc_enable_upll_clock();
   81b72:	4b04      	ldr	r3, [pc, #16]	; (81b84 <sysclk_enable_usb+0x14>)
   81b74:	4798      	blx	r3
		pmc_switch_udpck_to_upllck(CONFIG_USBCLK_DIV - 1);
   81b76:	2000      	movs	r0, #0
   81b78:	4b03      	ldr	r3, [pc, #12]	; (81b88 <sysclk_enable_usb+0x18>)
   81b7a:	4798      	blx	r3
		pmc_enable_udpck();
   81b7c:	4b03      	ldr	r3, [pc, #12]	; (81b8c <sysclk_enable_usb+0x1c>)
   81b7e:	4798      	blx	r3
   81b80:	bd08      	pop	{r3, pc}
   81b82:	bf00      	nop
   81b84:	00082019 	.word	0x00082019
   81b88:	00082085 	.word	0x00082085
   81b8c:	00082099 	.word	0x00082099

00081b90 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
   81b90:	b510      	push	{r4, lr}
	struct pll_config pllcfg;

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
   81b92:	480e      	ldr	r0, [pc, #56]	; (81bcc <sysclk_init+0x3c>)
   81b94:	4b0e      	ldr	r3, [pc, #56]	; (81bd0 <sysclk_init+0x40>)
   81b96:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
   81b98:	2000      	movs	r0, #0
   81b9a:	213e      	movs	r1, #62	; 0x3e
   81b9c:	4b0d      	ldr	r3, [pc, #52]	; (81bd4 <sysclk_init+0x44>)
   81b9e:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
   81ba0:	4c0d      	ldr	r4, [pc, #52]	; (81bd8 <sysclk_init+0x48>)
   81ba2:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
   81ba4:	2800      	cmp	r0, #0
   81ba6:	d0fc      	beq.n	81ba2 <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
   81ba8:	4b0c      	ldr	r3, [pc, #48]	; (81bdc <sysclk_init+0x4c>)
   81baa:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
   81bac:	4a0c      	ldr	r2, [pc, #48]	; (81be0 <sysclk_init+0x50>)
   81bae:	4b0d      	ldr	r3, [pc, #52]	; (81be4 <sysclk_init+0x54>)
   81bb0:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
   81bb2:	4c0d      	ldr	r4, [pc, #52]	; (81be8 <sysclk_init+0x58>)
   81bb4:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
   81bb6:	2800      	cmp	r0, #0
   81bb8:	d0fc      	beq.n	81bb4 <sysclk_init+0x24>
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
   81bba:	2010      	movs	r0, #16
   81bbc:	4b0b      	ldr	r3, [pc, #44]	; (81bec <sysclk_init+0x5c>)
   81bbe:	4798      	blx	r3
		pll_wait_for_lock(1);
		pmc_switch_mck_to_upllck(CONFIG_SYSCLK_PRES);
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
   81bc0:	4b0b      	ldr	r3, [pc, #44]	; (81bf0 <sysclk_init+0x60>)
   81bc2:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
   81bc4:	4801      	ldr	r0, [pc, #4]	; (81bcc <sysclk_init+0x3c>)
   81bc6:	4b02      	ldr	r3, [pc, #8]	; (81bd0 <sysclk_init+0x40>)
   81bc8:	4798      	blx	r3
   81bca:	bd10      	pop	{r4, pc}
   81bcc:	0501bd00 	.word	0x0501bd00
   81bd0:	200700a5 	.word	0x200700a5
   81bd4:	00081f95 	.word	0x00081f95
   81bd8:	00081fe9 	.word	0x00081fe9
   81bdc:	00081ff9 	.word	0x00081ff9
   81be0:	200d3f01 	.word	0x200d3f01
   81be4:	400e0600 	.word	0x400e0600
   81be8:	00082009 	.word	0x00082009
   81bec:	00081f2d 	.word	0x00081f2d
   81bf0:	0008217d 	.word	0x0008217d

00081bf4 <board_init>:
#include "conf_board.h"
#include "gpio.h"
#include "ioport.h"

void board_init(void)
{
   81bf4:	b510      	push	{r4, lr}
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
   81bf6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   81bfa:	4b16      	ldr	r3, [pc, #88]	; (81c54 <board_init+0x60>)
   81bfc:	605a      	str	r2, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
   81bfe:	200b      	movs	r0, #11
   81c00:	4c15      	ldr	r4, [pc, #84]	; (81c58 <board_init+0x64>)
   81c02:	47a0      	blx	r4
   81c04:	200c      	movs	r0, #12
   81c06:	47a0      	blx	r4
   81c08:	200d      	movs	r0, #13
   81c0a:	47a0      	blx	r4
   81c0c:	200e      	movs	r0, #14
   81c0e:	47a0      	blx	r4
	 * In new designs IOPORT is used instead.
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();
	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
   81c10:	203b      	movs	r0, #59	; 0x3b
   81c12:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c16:	4c11      	ldr	r4, [pc, #68]	; (81c5c <board_init+0x68>)
   81c18:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
   81c1a:	2055      	movs	r0, #85	; 0x55
   81c1c:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c20:	47a0      	blx	r4
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
   81c22:	2056      	movs	r0, #86	; 0x56
   81c24:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c28:	47a0      	blx	r4

	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
   81c2a:	2068      	movs	r0, #104	; 0x68
   81c2c:	490c      	ldr	r1, [pc, #48]	; (81c60 <board_init+0x6c>)
   81c2e:	47a0      	blx	r4
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
   81c30:	205c      	movs	r0, #92	; 0x5c
   81c32:	490c      	ldr	r1, [pc, #48]	; (81c64 <board_init+0x70>)
   81c34:	47a0      	blx	r4

#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART_PIO, PINS_UART, PINS_UART_FLAGS);
   81c36:	480c      	ldr	r0, [pc, #48]	; (81c68 <board_init+0x74>)
   81c38:	f44f 7140 	mov.w	r1, #768	; 0x300
   81c3c:	4a0b      	ldr	r2, [pc, #44]	; (81c6c <board_init+0x78>)
   81c3e:	4b0c      	ldr	r3, [pc, #48]	; (81c70 <board_init+0x7c>)
   81c40:	4798      	blx	r3
	gpio_configure_pin(PIN_USART0_TXD_IDX, PIN_USART0_TXD_FLAGS);
#endif

#ifdef CONF_BOARD_USB_PORT
	/* Configure USB_ID (UOTGID) pin */
	gpio_configure_pin(USB_ID_GPIO, USB_ID_FLAGS);
   81c42:	202b      	movs	r0, #43	; 0x2b
   81c44:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81c48:	47a0      	blx	r4
	/* Configure USB_VBOF (UOTGVBOF) pin */
	gpio_configure_pin(USB_VBOF_GPIO, USB_VBOF_FLAGS);
   81c4a:	202a      	movs	r0, #42	; 0x2a
   81c4c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81c50:	47a0      	blx	r4
   81c52:	bd10      	pop	{r4, pc}
   81c54:	400e1a50 	.word	0x400e1a50
   81c58:	00082031 	.word	0x00082031
   81c5c:	00081d19 	.word	0x00081d19
   81c60:	28000079 	.word	0x28000079
   81c64:	28000001 	.word	0x28000001
   81c68:	400e0e00 	.word	0x400e0e00
   81c6c:	08000001 	.word	0x08000001
   81c70:	00081ded 	.word	0x00081ded

00081c74 <pio_set_peripheral>:
		const uint32_t ul_mask)
{
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
   81c74:	6442      	str	r2, [r0, #68]	; 0x44
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
	}
#elif (SAM3XA|| SAM3U)
	switch (ul_type) {
   81c76:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
   81c7a:	d016      	beq.n	81caa <pio_set_peripheral+0x36>
   81c7c:	d804      	bhi.n	81c88 <pio_set_peripheral+0x14>
   81c7e:	b1c1      	cbz	r1, 81cb2 <pio_set_peripheral+0x3e>
   81c80:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
   81c84:	d00a      	beq.n	81c9c <pio_set_peripheral+0x28>
   81c86:	e013      	b.n	81cb0 <pio_set_peripheral+0x3c>
   81c88:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
   81c8c:	d011      	beq.n	81cb2 <pio_set_peripheral+0x3e>
   81c8e:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
   81c92:	d00e      	beq.n	81cb2 <pio_set_peripheral+0x3e>
   81c94:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
   81c98:	d10a      	bne.n	81cb0 <pio_set_peripheral+0x3c>
   81c9a:	4770      	bx	lr
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABSR;
   81c9c:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR &= (~ul_mask & ul_sr);
   81c9e:	6f01      	ldr	r1, [r0, #112]	; 0x70
   81ca0:	400b      	ands	r3, r1
   81ca2:	ea23 0302 	bic.w	r3, r3, r2
   81ca6:	6703      	str	r3, [r0, #112]	; 0x70
		break;
   81ca8:	e002      	b.n	81cb0 <pio_set_peripheral+0x3c>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABSR;
   81caa:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR = (ul_mask | ul_sr);
   81cac:	4313      	orrs	r3, r2
   81cae:	6703      	str	r3, [r0, #112]	; 0x70
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
   81cb0:	6042      	str	r2, [r0, #4]
   81cb2:	4770      	bx	lr

00081cb4 <pio_set_input>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
   81cb4:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81cb6:	f012 0f01 	tst.w	r2, #1
		p_pio->PIO_PUER = ul_mask;
   81cba:	bf14      	ite	ne
   81cbc:	6641      	strne	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81cbe:	6601      	streq	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
   81cc0:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
   81cc4:	bf14      	ite	ne
   81cc6:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
   81cc8:	6241      	streq	r1, [r0, #36]	; 0x24
			p_pio->PIO_IFSCER = ul_mask;
		}
	}
#elif (SAM3XA|| SAM3U)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
   81cca:	f012 0f02 	tst.w	r2, #2
   81cce:	d002      	beq.n	81cd6 <pio_set_input+0x22>
		p_pio->PIO_SCIFSR = ul_mask;
   81cd0:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
   81cd4:	e004      	b.n	81ce0 <pio_set_input+0x2c>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
   81cd6:	f012 0f08 	tst.w	r2, #8
			p_pio->PIO_DIFSR = ul_mask;
   81cda:	bf18      	it	ne
   81cdc:	f8c0 1084 	strne.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
   81ce0:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
   81ce2:	6001      	str	r1, [r0, #0]
   81ce4:	4770      	bx	lr
   81ce6:	bf00      	nop

00081ce8 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
   81ce8:	b410      	push	{r4}
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
   81cea:	6441      	str	r1, [r0, #68]	; 0x44
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81cec:	9c01      	ldr	r4, [sp, #4]
   81cee:	b10c      	cbz	r4, 81cf4 <pio_set_output+0xc>
		p_pio->PIO_PUER = ul_mask;
   81cf0:	6641      	str	r1, [r0, #100]	; 0x64
   81cf2:	e000      	b.n	81cf6 <pio_set_output+0xe>
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81cf4:	6601      	str	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
   81cf6:	b10b      	cbz	r3, 81cfc <pio_set_output+0x14>
		p_pio->PIO_MDER = ul_mask;
   81cf8:	6501      	str	r1, [r0, #80]	; 0x50
   81cfa:	e000      	b.n	81cfe <pio_set_output+0x16>
	} else {
		p_pio->PIO_MDDR = ul_mask;
   81cfc:	6541      	str	r1, [r0, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
   81cfe:	b10a      	cbz	r2, 81d04 <pio_set_output+0x1c>
		p_pio->PIO_SODR = ul_mask;
   81d00:	6301      	str	r1, [r0, #48]	; 0x30
   81d02:	e000      	b.n	81d06 <pio_set_output+0x1e>
	} else {
		p_pio->PIO_CODR = ul_mask;
   81d04:	6341      	str	r1, [r0, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
   81d06:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
   81d08:	6001      	str	r1, [r0, #0]
}
   81d0a:	f85d 4b04 	ldr.w	r4, [sp], #4
   81d0e:	4770      	bx	lr

00081d10 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
   81d10:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
   81d12:	4770      	bx	lr

00081d14 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
   81d14:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
   81d16:	4770      	bx	lr

00081d18 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
   81d18:	b570      	push	{r4, r5, r6, lr}
   81d1a:	b082      	sub	sp, #8
   81d1c:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   81d1e:	0943      	lsrs	r3, r0, #5
   81d20:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   81d24:	f203 7307 	addw	r3, r3, #1799	; 0x707
   81d28:	025c      	lsls	r4, r3, #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
   81d2a:	f001 43f0 	and.w	r3, r1, #2013265920	; 0x78000000
   81d2e:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   81d32:	d030      	beq.n	81d96 <pio_configure_pin+0x7e>
   81d34:	d806      	bhi.n	81d44 <pio_configure_pin+0x2c>
   81d36:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   81d3a:	d00a      	beq.n	81d52 <pio_configure_pin+0x3a>
   81d3c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   81d40:	d018      	beq.n	81d74 <pio_configure_pin+0x5c>
   81d42:	e049      	b.n	81dd8 <pio_configure_pin+0xc0>
   81d44:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   81d48:	d030      	beq.n	81dac <pio_configure_pin+0x94>
   81d4a:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   81d4e:	d02d      	beq.n	81dac <pio_configure_pin+0x94>
   81d50:	e042      	b.n	81dd8 <pio_configure_pin+0xc0>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
   81d52:	f000 001f 	and.w	r0, r0, #31
   81d56:	2601      	movs	r6, #1
   81d58:	4086      	lsls	r6, r0
   81d5a:	4620      	mov	r0, r4
   81d5c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81d60:	4632      	mov	r2, r6
   81d62:	4b1f      	ldr	r3, [pc, #124]	; (81de0 <pio_configure_pin+0xc8>)
   81d64:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81d66:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   81d6a:	bf14      	ite	ne
   81d6c:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81d6e:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   81d70:	2001      	movs	r0, #1
   81d72:	e032      	b.n	81dda <pio_configure_pin+0xc2>
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
   81d74:	f000 001f 	and.w	r0, r0, #31
   81d78:	2601      	movs	r6, #1
   81d7a:	4086      	lsls	r6, r0
   81d7c:	4620      	mov	r0, r4
   81d7e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   81d82:	4632      	mov	r2, r6
   81d84:	4b16      	ldr	r3, [pc, #88]	; (81de0 <pio_configure_pin+0xc8>)
   81d86:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81d88:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   81d8c:	bf14      	ite	ne
   81d8e:	6666      	strne	r6, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81d90:	6626      	streq	r6, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   81d92:	2001      	movs	r0, #1
   81d94:	e021      	b.n	81dda <pio_configure_pin+0xc2>
				(ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
   81d96:	f000 031f 	and.w	r3, r0, #31
   81d9a:	2601      	movs	r6, #1
   81d9c:	4620      	mov	r0, r4
   81d9e:	fa06 f103 	lsl.w	r1, r6, r3
   81da2:	462a      	mov	r2, r5
   81da4:	4b0f      	ldr	r3, [pc, #60]	; (81de4 <pio_configure_pin+0xcc>)
   81da6:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
   81da8:	4630      	mov	r0, r6
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
   81daa:	e016      	b.n	81dda <pio_configure_pin+0xc2>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   81dac:	f000 031f 	and.w	r3, r0, #31
   81db0:	2601      	movs	r6, #1
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   81db2:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   81db6:	ea05 0106 	and.w	r1, r5, r6
   81dba:	9100      	str	r1, [sp, #0]
   81dbc:	4620      	mov	r0, r4
   81dbe:	fa06 f103 	lsl.w	r1, r6, r3
   81dc2:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
   81dc6:	bf14      	ite	ne
   81dc8:	2200      	movne	r2, #0
   81dca:	2201      	moveq	r2, #1
   81dcc:	f3c5 0380 	ubfx	r3, r5, #2, #1
   81dd0:	4c05      	ldr	r4, [pc, #20]	; (81de8 <pio_configure_pin+0xd0>)
   81dd2:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
   81dd4:	4630      	mov	r0, r6
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
   81dd6:	e000      	b.n	81dda <pio_configure_pin+0xc2>

	default:
		return 0;
   81dd8:	2000      	movs	r0, #0
	}

	return 1;
}
   81dda:	b002      	add	sp, #8
   81ddc:	bd70      	pop	{r4, r5, r6, pc}
   81dde:	bf00      	nop
   81de0:	00081c75 	.word	0x00081c75
   81de4:	00081cb5 	.word	0x00081cb5
   81de8:	00081ce9 	.word	0x00081ce9

00081dec <pio_configure_pin_group>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
   81dec:	b570      	push	{r4, r5, r6, lr}
   81dee:	b082      	sub	sp, #8
   81df0:	4606      	mov	r6, r0
   81df2:	460d      	mov	r5, r1
   81df4:	4614      	mov	r4, r2
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
   81df6:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
   81dfa:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   81dfe:	d026      	beq.n	81e4e <pio_configure_pin_group+0x62>
   81e00:	d806      	bhi.n	81e10 <pio_configure_pin_group+0x24>
   81e02:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   81e06:	d00a      	beq.n	81e1e <pio_configure_pin_group+0x32>
   81e08:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   81e0c:	d013      	beq.n	81e36 <pio_configure_pin_group+0x4a>
   81e0e:	e034      	b.n	81e7a <pio_configure_pin_group+0x8e>
   81e10:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   81e14:	d01f      	beq.n	81e56 <pio_configure_pin_group+0x6a>
   81e16:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   81e1a:	d01c      	beq.n	81e56 <pio_configure_pin_group+0x6a>
   81e1c:	e02d      	b.n	81e7a <pio_configure_pin_group+0x8e>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
   81e1e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e22:	462a      	mov	r2, r5
   81e24:	4b16      	ldr	r3, [pc, #88]	; (81e80 <pio_configure_pin_group+0x94>)
   81e26:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81e28:	f014 0f01 	tst.w	r4, #1
		p_pio->PIO_PUER = ul_mask;
   81e2c:	bf14      	ite	ne
   81e2e:	6675      	strne	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81e30:	6635      	streq	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   81e32:	2001      	movs	r0, #1
   81e34:	e022      	b.n	81e7c <pio_configure_pin_group+0x90>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
   81e36:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   81e3a:	462a      	mov	r2, r5
   81e3c:	4b10      	ldr	r3, [pc, #64]	; (81e80 <pio_configure_pin_group+0x94>)
   81e3e:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   81e40:	f014 0f01 	tst.w	r4, #1
		p_pio->PIO_PUER = ul_mask;
   81e44:	bf14      	ite	ne
   81e46:	6675      	strne	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
   81e48:	6635      	streq	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
   81e4a:	2001      	movs	r0, #1
   81e4c:	e016      	b.n	81e7c <pio_configure_pin_group+0x90>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
   81e4e:	4b0d      	ldr	r3, [pc, #52]	; (81e84 <pio_configure_pin_group+0x98>)
   81e50:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
   81e52:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
   81e54:	e012      	b.n	81e7c <pio_configure_pin_group+0x90>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   81e56:	f004 5260 	and.w	r2, r4, #939524096	; 0x38000000
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
   81e5a:	f004 0301 	and.w	r3, r4, #1
   81e5e:	9300      	str	r3, [sp, #0]
   81e60:	4630      	mov	r0, r6
   81e62:	4629      	mov	r1, r5
   81e64:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
   81e68:	bf14      	ite	ne
   81e6a:	2200      	movne	r2, #0
   81e6c:	2201      	moveq	r2, #1
   81e6e:	f3c4 0380 	ubfx	r3, r4, #2, #1
   81e72:	4c05      	ldr	r4, [pc, #20]	; (81e88 <pio_configure_pin_group+0x9c>)
   81e74:	47a0      	blx	r4

	default:
		return 0;
	}

	return 1;
   81e76:	2001      	movs	r0, #1
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
   81e78:	e000      	b.n	81e7c <pio_configure_pin_group+0x90>

	default:
		return 0;
   81e7a:	2000      	movs	r0, #0
	}

	return 1;
}
   81e7c:	b002      	add	sp, #8
   81e7e:	bd70      	pop	{r4, r5, r6, pc}
   81e80:	00081c75 	.word	0x00081c75
   81e84:	00081cb5 	.word	0x00081cb5
   81e88:	00081ce9 	.word	0x00081ce9

00081e8c <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
   81e8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   81e90:	4604      	mov	r4, r0
   81e92:	4688      	mov	r8, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
   81e94:	4b0e      	ldr	r3, [pc, #56]	; (81ed0 <pio_handler_process+0x44>)
   81e96:	4798      	blx	r3
   81e98:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
   81e9a:	4620      	mov	r0, r4
   81e9c:	4b0d      	ldr	r3, [pc, #52]	; (81ed4 <pio_handler_process+0x48>)
   81e9e:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
   81ea0:	4005      	ands	r5, r0
   81ea2:	d013      	beq.n	81ecc <pio_handler_process+0x40>
   81ea4:	4c0c      	ldr	r4, [pc, #48]	; (81ed8 <pio_handler_process+0x4c>)
   81ea6:	f104 0660 	add.w	r6, r4, #96	; 0x60
		/* Find triggering source */
		i = 0;
		while (status != 0) {
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
   81eaa:	6823      	ldr	r3, [r4, #0]
   81eac:	4543      	cmp	r3, r8
   81eae:	d108      	bne.n	81ec2 <pio_handler_process+0x36>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
   81eb0:	6861      	ldr	r1, [r4, #4]
   81eb2:	4229      	tst	r1, r5
   81eb4:	d005      	beq.n	81ec2 <pio_handler_process+0x36>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
   81eb6:	68e3      	ldr	r3, [r4, #12]
   81eb8:	4640      	mov	r0, r8
   81eba:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
   81ebc:	6863      	ldr	r3, [r4, #4]
   81ebe:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
   81ec2:	42b4      	cmp	r4, r6
   81ec4:	d002      	beq.n	81ecc <pio_handler_process+0x40>
   81ec6:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
   81ec8:	2d00      	cmp	r5, #0
   81eca:	d1ee      	bne.n	81eaa <pio_handler_process+0x1e>
   81ecc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81ed0:	00081d11 	.word	0x00081d11
   81ed4:	00081d15 	.word	0x00081d15
   81ed8:	200706a4 	.word	0x200706a4

00081edc <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
   81edc:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
   81ede:	4802      	ldr	r0, [pc, #8]	; (81ee8 <PIOA_Handler+0xc>)
   81ee0:	210b      	movs	r1, #11
   81ee2:	4b02      	ldr	r3, [pc, #8]	; (81eec <PIOA_Handler+0x10>)
   81ee4:	4798      	blx	r3
   81ee6:	bd08      	pop	{r3, pc}
   81ee8:	400e0e00 	.word	0x400e0e00
   81eec:	00081e8d 	.word	0x00081e8d

00081ef0 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
   81ef0:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
   81ef2:	4802      	ldr	r0, [pc, #8]	; (81efc <PIOB_Handler+0xc>)
   81ef4:	210c      	movs	r1, #12
   81ef6:	4b02      	ldr	r3, [pc, #8]	; (81f00 <PIOB_Handler+0x10>)
   81ef8:	4798      	blx	r3
   81efa:	bd08      	pop	{r3, pc}
   81efc:	400e1000 	.word	0x400e1000
   81f00:	00081e8d 	.word	0x00081e8d

00081f04 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
   81f04:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
   81f06:	4802      	ldr	r0, [pc, #8]	; (81f10 <PIOC_Handler+0xc>)
   81f08:	210d      	movs	r1, #13
   81f0a:	4b02      	ldr	r3, [pc, #8]	; (81f14 <PIOC_Handler+0x10>)
   81f0c:	4798      	blx	r3
   81f0e:	bd08      	pop	{r3, pc}
   81f10:	400e1200 	.word	0x400e1200
   81f14:	00081e8d 	.word	0x00081e8d

00081f18 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
   81f18:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
   81f1a:	4802      	ldr	r0, [pc, #8]	; (81f24 <PIOD_Handler+0xc>)
   81f1c:	210e      	movs	r1, #14
   81f1e:	4b02      	ldr	r3, [pc, #8]	; (81f28 <PIOD_Handler+0x10>)
   81f20:	4798      	blx	r3
   81f22:	bd08      	pop	{r3, pc}
   81f24:	400e1400 	.word	0x400e1400
   81f28:	00081e8d 	.word	0x00081e8d

00081f2c <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
   81f2c:	4a18      	ldr	r2, [pc, #96]	; (81f90 <pmc_switch_mck_to_pllack+0x64>)
   81f2e:	6b13      	ldr	r3, [r2, #48]	; 0x30
   81f30:	f023 0370 	bic.w	r3, r3, #112	; 0x70
   81f34:	4318      	orrs	r0, r3
   81f36:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f38:	6e93      	ldr	r3, [r2, #104]	; 0x68
   81f3a:	f013 0f08 	tst.w	r3, #8
   81f3e:	d003      	beq.n	81f48 <pmc_switch_mck_to_pllack+0x1c>
   81f40:	e009      	b.n	81f56 <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
   81f42:	3b01      	subs	r3, #1
   81f44:	d103      	bne.n	81f4e <pmc_switch_mck_to_pllack+0x22>
   81f46:	e01e      	b.n	81f86 <pmc_switch_mck_to_pllack+0x5a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f48:	f44f 6300 	mov.w	r3, #2048	; 0x800
   81f4c:	4910      	ldr	r1, [pc, #64]	; (81f90 <pmc_switch_mck_to_pllack+0x64>)
   81f4e:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   81f50:	f012 0f08 	tst.w	r2, #8
   81f54:	d0f5      	beq.n	81f42 <pmc_switch_mck_to_pllack+0x16>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
   81f56:	4a0e      	ldr	r2, [pc, #56]	; (81f90 <pmc_switch_mck_to_pllack+0x64>)
   81f58:	6b13      	ldr	r3, [r2, #48]	; 0x30
   81f5a:	f023 0303 	bic.w	r3, r3, #3
   81f5e:	f043 0302 	orr.w	r3, r3, #2
   81f62:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f64:	6e90      	ldr	r0, [r2, #104]	; 0x68
   81f66:	f010 0008 	ands.w	r0, r0, #8
   81f6a:	d004      	beq.n	81f76 <pmc_switch_mck_to_pllack+0x4a>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
   81f6c:	2000      	movs	r0, #0
   81f6e:	4770      	bx	lr
	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
   81f70:	3b01      	subs	r3, #1
   81f72:	d103      	bne.n	81f7c <pmc_switch_mck_to_pllack+0x50>
   81f74:	e009      	b.n	81f8a <pmc_switch_mck_to_pllack+0x5e>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f76:	f44f 6300 	mov.w	r3, #2048	; 0x800
   81f7a:	4905      	ldr	r1, [pc, #20]	; (81f90 <pmc_switch_mck_to_pllack+0x64>)
   81f7c:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   81f7e:	f012 0f08 	tst.w	r2, #8
   81f82:	d0f5      	beq.n	81f70 <pmc_switch_mck_to_pllack+0x44>
   81f84:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
   81f86:	2001      	movs	r0, #1
   81f88:	4770      	bx	lr
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
   81f8a:	2001      	movs	r0, #1
		}
	}

	return 0;
}
   81f8c:	4770      	bx	lr
   81f8e:	bf00      	nop
   81f90:	400e0600 	.word	0x400e0600

00081f94 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
   81f94:	b138      	cbz	r0, 81fa6 <pmc_switch_mainck_to_xtal+0x12>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   81f96:	4911      	ldr	r1, [pc, #68]	; (81fdc <pmc_switch_mainck_to_xtal+0x48>)
   81f98:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
   81f9a:	4a11      	ldr	r2, [pc, #68]	; (81fe0 <pmc_switch_mainck_to_xtal+0x4c>)
   81f9c:	401a      	ands	r2, r3
   81f9e:	4b11      	ldr	r3, [pc, #68]	; (81fe4 <pmc_switch_mainck_to_xtal+0x50>)
   81fa0:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   81fa2:	620b      	str	r3, [r1, #32]
   81fa4:	4770      	bx	lr
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   81fa6:	4a0d      	ldr	r2, [pc, #52]	; (81fdc <pmc_switch_mainck_to_xtal+0x48>)
   81fa8:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
   81faa:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
   81fae:	f023 0303 	bic.w	r3, r3, #3
   81fb2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   81fb6:	f043 0301 	orr.w	r3, r3, #1
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
   81fba:	0209      	lsls	r1, r1, #8
   81fbc:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
   81fbe:	430b      	orrs	r3, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   81fc0:	6213      	str	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
   81fc2:	6e93      	ldr	r3, [r2, #104]	; 0x68
   81fc4:	f013 0f01 	tst.w	r3, #1
   81fc8:	d0fb      	beq.n	81fc2 <pmc_switch_mainck_to_xtal+0x2e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
   81fca:	4a04      	ldr	r2, [pc, #16]	; (81fdc <pmc_switch_mainck_to_xtal+0x48>)
   81fcc:	6a13      	ldr	r3, [r2, #32]
   81fce:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
   81fd2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   81fd6:	6213      	str	r3, [r2, #32]
   81fd8:	4770      	bx	lr
   81fda:	bf00      	nop
   81fdc:	400e0600 	.word	0x400e0600
   81fe0:	fec8fffc 	.word	0xfec8fffc
   81fe4:	01370002 	.word	0x01370002

00081fe8 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
   81fe8:	4b02      	ldr	r3, [pc, #8]	; (81ff4 <pmc_osc_is_ready_mainck+0xc>)
   81fea:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   81fec:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
   81ff0:	4770      	bx	lr
   81ff2:	bf00      	nop
   81ff4:	400e0600 	.word	0x400e0600

00081ff8 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
   81ff8:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   81ffc:	4b01      	ldr	r3, [pc, #4]	; (82004 <pmc_disable_pllack+0xc>)
   81ffe:	629a      	str	r2, [r3, #40]	; 0x28
   82000:	4770      	bx	lr
   82002:	bf00      	nop
   82004:	400e0600 	.word	0x400e0600

00082008 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
   82008:	4b02      	ldr	r3, [pc, #8]	; (82014 <pmc_is_locked_pllack+0xc>)
   8200a:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   8200c:	f000 0002 	and.w	r0, r0, #2
   82010:	4770      	bx	lr
   82012:	bf00      	nop
   82014:	400e0600 	.word	0x400e0600

00082018 <pmc_enable_upll_clock>:
/**
 * \brief Enable UPLL clock.
 */
void pmc_enable_upll_clock(void)
{
	PMC->CKGR_UCKR = CKGR_UCKR_UPLLCOUNT(3) | CKGR_UCKR_UPLLEN;
   82018:	f44f 1244 	mov.w	r2, #3211264	; 0x310000
   8201c:	4b03      	ldr	r3, [pc, #12]	; (8202c <pmc_enable_upll_clock+0x14>)
   8201e:	61da      	str	r2, [r3, #28]

	/* Wait UTMI PLL Lock Status */
	while (!(PMC->PMC_SR & PMC_SR_LOCKU));
   82020:	461a      	mov	r2, r3
   82022:	6e93      	ldr	r3, [r2, #104]	; 0x68
   82024:	f013 0f40 	tst.w	r3, #64	; 0x40
   82028:	d0fb      	beq.n	82022 <pmc_enable_upll_clock+0xa>
}
   8202a:	4770      	bx	lr
   8202c:	400e0600 	.word	0x400e0600

00082030 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
   82030:	282c      	cmp	r0, #44	; 0x2c
   82032:	d81e      	bhi.n	82072 <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
   82034:	281f      	cmp	r0, #31
   82036:	d80c      	bhi.n	82052 <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   82038:	4b11      	ldr	r3, [pc, #68]	; (82080 <pmc_enable_periph_clk+0x50>)
   8203a:	699a      	ldr	r2, [r3, #24]
   8203c:	2301      	movs	r3, #1
   8203e:	4083      	lsls	r3, r0
   82040:	401a      	ands	r2, r3
   82042:	4293      	cmp	r3, r2
   82044:	d017      	beq.n	82076 <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
   82046:	2301      	movs	r3, #1
   82048:	4083      	lsls	r3, r0
   8204a:	4a0d      	ldr	r2, [pc, #52]	; (82080 <pmc_enable_periph_clk+0x50>)
   8204c:	6113      	str	r3, [r2, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
   8204e:	2000      	movs	r0, #0
   82050:	4770      	bx	lr
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   82052:	4b0b      	ldr	r3, [pc, #44]	; (82080 <pmc_enable_periph_clk+0x50>)
   82054:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
   82058:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   8205a:	2301      	movs	r3, #1
   8205c:	4083      	lsls	r3, r0
   8205e:	401a      	ands	r2, r3
   82060:	4293      	cmp	r3, r2
   82062:	d00a      	beq.n	8207a <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
   82064:	2301      	movs	r3, #1
   82066:	4083      	lsls	r3, r0
   82068:	4a05      	ldr	r2, [pc, #20]	; (82080 <pmc_enable_periph_clk+0x50>)
   8206a:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
   8206e:	2000      	movs	r0, #0
   82070:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
   82072:	2001      	movs	r0, #1
   82074:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
   82076:	2000      	movs	r0, #0
   82078:	4770      	bx	lr
   8207a:	2000      	movs	r0, #0
}
   8207c:	4770      	bx	lr
   8207e:	bf00      	nop
   82080:	400e0600 	.word	0x400e0600

00082084 <pmc_switch_udpck_to_upllck>:
 *
 * \param ul_usbdiv Clock divisor.
 */
void pmc_switch_udpck_to_upllck(uint32_t ul_usbdiv)
{
	PMC->PMC_USB = PMC_USB_USBS | PMC_USB_USBDIV(ul_usbdiv);
   82084:	0200      	lsls	r0, r0, #8
   82086:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
   8208a:	f040 0001 	orr.w	r0, r0, #1
   8208e:	4b01      	ldr	r3, [pc, #4]	; (82094 <pmc_switch_udpck_to_upllck+0x10>)
   82090:	6398      	str	r0, [r3, #56]	; 0x38
   82092:	4770      	bx	lr
   82094:	400e0600 	.word	0x400e0600

00082098 <pmc_enable_udpck>:
#if (SAM3S || SAM4S || SAM4E || SAMG55)
	PMC->PMC_SCER = PMC_SCER_UDP;
#elif (SAMV71 || SAMV70 || SAME70 || SAMS70)
	PMC->PMC_SCER = PMC_SCER_USBCLK;
#else
	PMC->PMC_SCER = PMC_SCER_UOTGCLK;
   82098:	2220      	movs	r2, #32
   8209a:	4b01      	ldr	r3, [pc, #4]	; (820a0 <pmc_enable_udpck+0x8>)
   8209c:	601a      	str	r2, [r3, #0]
   8209e:	4770      	bx	lr
   820a0:	400e0600 	.word	0x400e0600

000820a4 <pmc_set_fast_startup_input>:
 * \param ul_inputs Wake up inputs to enable.
 */
void pmc_set_fast_startup_input(uint32_t ul_inputs)
{
	ul_inputs &= PMC_FAST_STARTUP_Msk;
	PMC->PMC_FSMR |= ul_inputs;
   820a4:	4a03      	ldr	r2, [pc, #12]	; (820b4 <pmc_set_fast_startup_input+0x10>)
   820a6:	6f13      	ldr	r3, [r2, #112]	; 0x70
 *
 * \param ul_inputs Wake up inputs to enable.
 */
void pmc_set_fast_startup_input(uint32_t ul_inputs)
{
	ul_inputs &= PMC_FAST_STARTUP_Msk;
   820a8:	f3c0 0012 	ubfx	r0, r0, #0, #19
	PMC->PMC_FSMR |= ul_inputs;
   820ac:	4303      	orrs	r3, r0
   820ae:	6713      	str	r3, [r2, #112]	; 0x70
   820b0:	4770      	bx	lr
   820b2:	bf00      	nop
   820b4:	400e0600 	.word	0x400e0600

000820b8 <pmc_is_wakeup_clocks_restored>:
	}
}

bool pmc_is_wakeup_clocks_restored(void)
{
	return !b_is_sleep_clock_used;
   820b8:	4b02      	ldr	r3, [pc, #8]	; (820c4 <pmc_is_wakeup_clocks_restored+0xc>)
   820ba:	7818      	ldrb	r0, [r3, #0]
}
   820bc:	f080 0001 	eor.w	r0, r0, #1
   820c0:	4770      	bx	lr
   820c2:	bf00      	nop
   820c4:	20070714 	.word	0x20070714

000820c8 <Dummy_Handler>:
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
	}
   820c8:	e7fe      	b.n	820c8 <Dummy_Handler>
   820ca:	bf00      	nop

000820cc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   820cc:	b508      	push	{r3, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   820ce:	4b1f      	ldr	r3, [pc, #124]	; (8214c <Reset_Handler+0x80>)
   820d0:	4a1f      	ldr	r2, [pc, #124]	; (82150 <Reset_Handler+0x84>)
   820d2:	429a      	cmp	r2, r3
   820d4:	d003      	beq.n	820de <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
   820d6:	4b1f      	ldr	r3, [pc, #124]	; (82154 <Reset_Handler+0x88>)
   820d8:	4a1c      	ldr	r2, [pc, #112]	; (8214c <Reset_Handler+0x80>)
   820da:	429a      	cmp	r2, r3
   820dc:	d304      	bcc.n	820e8 <Reset_Handler+0x1c>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   820de:	4b1e      	ldr	r3, [pc, #120]	; (82158 <Reset_Handler+0x8c>)
   820e0:	4a1e      	ldr	r2, [pc, #120]	; (8215c <Reset_Handler+0x90>)
   820e2:	429a      	cmp	r2, r3
   820e4:	d310      	bcc.n	82108 <Reset_Handler+0x3c>
   820e6:	e01b      	b.n	82120 <Reset_Handler+0x54>
   820e8:	4918      	ldr	r1, [pc, #96]	; (8214c <Reset_Handler+0x80>)
   820ea:	1d0a      	adds	r2, r1, #4
   820ec:	4b1c      	ldr	r3, [pc, #112]	; (82160 <Reset_Handler+0x94>)
   820ee:	1a9b      	subs	r3, r3, r2
   820f0:	f023 0303 	bic.w	r3, r3, #3
   820f4:	3304      	adds	r3, #4
   820f6:	4a16      	ldr	r2, [pc, #88]	; (82150 <Reset_Handler+0x84>)
   820f8:	4413      	add	r3, r2
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
   820fa:	f852 0b04 	ldr.w	r0, [r2], #4
   820fe:	f841 0b04 	str.w	r0, [r1], #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
   82102:	429a      	cmp	r2, r3
   82104:	d1f9      	bne.n	820fa <Reset_Handler+0x2e>
   82106:	e7ea      	b.n	820de <Reset_Handler+0x12>
   82108:	4b16      	ldr	r3, [pc, #88]	; (82164 <Reset_Handler+0x98>)
   8210a:	4a17      	ldr	r2, [pc, #92]	; (82168 <Reset_Handler+0x9c>)
   8210c:	1ad2      	subs	r2, r2, r3
   8210e:	f022 0203 	bic.w	r2, r2, #3
   82112:	441a      	add	r2, r3
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   82114:	3b04      	subs	r3, #4
		*pDest++ = 0;
   82116:	2100      	movs	r1, #0
   82118:	f843 1b04 	str.w	r1, [r3], #4
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   8211c:	4293      	cmp	r3, r2
   8211e:	d1fb      	bne.n	82118 <Reset_Handler+0x4c>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   82120:	4b12      	ldr	r3, [pc, #72]	; (8216c <Reset_Handler+0xa0>)
   82122:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
   82126:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   8212a:	4911      	ldr	r1, [pc, #68]	; (82170 <Reset_Handler+0xa4>)
   8212c:	608a      	str	r2, [r1, #8]

	if (((uint32_t) pSrc >= IRAM0_ADDR) && ((uint32_t) pSrc < NFC_RAM_ADDR)) {
   8212e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   82132:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   82136:	d203      	bcs.n	82140 <Reset_Handler+0x74>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
   82138:	688b      	ldr	r3, [r1, #8]
   8213a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   8213e:	608b      	str	r3, [r1, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
   82140:	4b0c      	ldr	r3, [pc, #48]	; (82174 <Reset_Handler+0xa8>)
   82142:	4798      	blx	r3

	/* Branch to main function */
	main();
   82144:	4b0c      	ldr	r3, [pc, #48]	; (82178 <Reset_Handler+0xac>)
   82146:	4798      	blx	r3

	/* Infinite loop */
	while (1);
   82148:	e7fe      	b.n	82148 <Reset_Handler+0x7c>
   8214a:	bf00      	nop
   8214c:	20070000 	.word	0x20070000
   82150:	00082450 	.word	0x00082450
   82154:	20070638 	.word	0x20070638
   82158:	20070738 	.word	0x20070738
   8215c:	20070638 	.word	0x20070638
   82160:	2007063b 	.word	0x2007063b
   82164:	2007063c 	.word	0x2007063c
   82168:	2007073b 	.word	0x2007073b
   8216c:	00080000 	.word	0x00080000
   82170:	e000ed00 	.word	0xe000ed00
   82174:	000822dd 	.word	0x000822dd
   82178:	00082299 	.word	0x00082299

0008217c <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
   8217c:	4b3e      	ldr	r3, [pc, #248]	; (82278 <SystemCoreClockUpdate+0xfc>)
   8217e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   82180:	f003 0303 	and.w	r3, r3, #3
   82184:	2b03      	cmp	r3, #3
   82186:	d85f      	bhi.n	82248 <SystemCoreClockUpdate+0xcc>
   82188:	e8df f003 	tbb	[pc, r3]
   8218c:	2b2b0e02 	.word	0x2b2b0e02
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
   82190:	4b3a      	ldr	r3, [pc, #232]	; (8227c <SystemCoreClockUpdate+0x100>)
   82192:	695b      	ldr	r3, [r3, #20]
   82194:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
   82198:	bf14      	ite	ne
   8219a:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
   8219e:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
   821a2:	4b37      	ldr	r3, [pc, #220]	; (82280 <SystemCoreClockUpdate+0x104>)
   821a4:	601a      	str	r2, [r3, #0]
   821a6:	e04f      	b.n	82248 <SystemCoreClockUpdate+0xcc>
		}
		break;
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   821a8:	4b33      	ldr	r3, [pc, #204]	; (82278 <SystemCoreClockUpdate+0xfc>)
   821aa:	6a1b      	ldr	r3, [r3, #32]
   821ac:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   821b0:	d003      	beq.n	821ba <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   821b2:	4a34      	ldr	r2, [pc, #208]	; (82284 <SystemCoreClockUpdate+0x108>)
   821b4:	4b32      	ldr	r3, [pc, #200]	; (82280 <SystemCoreClockUpdate+0x104>)
   821b6:	601a      	str	r2, [r3, #0]
   821b8:	e046      	b.n	82248 <SystemCoreClockUpdate+0xcc>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   821ba:	4a33      	ldr	r2, [pc, #204]	; (82288 <SystemCoreClockUpdate+0x10c>)
   821bc:	4b30      	ldr	r3, [pc, #192]	; (82280 <SystemCoreClockUpdate+0x104>)
   821be:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   821c0:	4b2d      	ldr	r3, [pc, #180]	; (82278 <SystemCoreClockUpdate+0xfc>)
   821c2:	6a1b      	ldr	r3, [r3, #32]
   821c4:	f003 0370 	and.w	r3, r3, #112	; 0x70
   821c8:	2b10      	cmp	r3, #16
   821ca:	d002      	beq.n	821d2 <SystemCoreClockUpdate+0x56>
   821cc:	2b20      	cmp	r3, #32
   821ce:	d004      	beq.n	821da <SystemCoreClockUpdate+0x5e>
   821d0:	e03a      	b.n	82248 <SystemCoreClockUpdate+0xcc>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   821d2:	4a2e      	ldr	r2, [pc, #184]	; (8228c <SystemCoreClockUpdate+0x110>)
   821d4:	4b2a      	ldr	r3, [pc, #168]	; (82280 <SystemCoreClockUpdate+0x104>)
   821d6:	601a      	str	r2, [r3, #0]
				break;
   821d8:	e036      	b.n	82248 <SystemCoreClockUpdate+0xcc>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   821da:	4a2a      	ldr	r2, [pc, #168]	; (82284 <SystemCoreClockUpdate+0x108>)
   821dc:	4b28      	ldr	r3, [pc, #160]	; (82280 <SystemCoreClockUpdate+0x104>)
   821de:	601a      	str	r2, [r3, #0]
				break;
   821e0:	e032      	b.n	82248 <SystemCoreClockUpdate+0xcc>
			}
		}
		break;
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_UPLL_CLK:	/* UPLL clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   821e2:	4b25      	ldr	r3, [pc, #148]	; (82278 <SystemCoreClockUpdate+0xfc>)
   821e4:	6a1b      	ldr	r3, [r3, #32]
   821e6:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   821ea:	d003      	beq.n	821f4 <SystemCoreClockUpdate+0x78>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   821ec:	4a25      	ldr	r2, [pc, #148]	; (82284 <SystemCoreClockUpdate+0x108>)
   821ee:	4b24      	ldr	r3, [pc, #144]	; (82280 <SystemCoreClockUpdate+0x104>)
   821f0:	601a      	str	r2, [r3, #0]
   821f2:	e012      	b.n	8221a <SystemCoreClockUpdate+0x9e>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   821f4:	4a24      	ldr	r2, [pc, #144]	; (82288 <SystemCoreClockUpdate+0x10c>)
   821f6:	4b22      	ldr	r3, [pc, #136]	; (82280 <SystemCoreClockUpdate+0x104>)
   821f8:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   821fa:	4b1f      	ldr	r3, [pc, #124]	; (82278 <SystemCoreClockUpdate+0xfc>)
   821fc:	6a1b      	ldr	r3, [r3, #32]
   821fe:	f003 0370 	and.w	r3, r3, #112	; 0x70
   82202:	2b10      	cmp	r3, #16
   82204:	d002      	beq.n	8220c <SystemCoreClockUpdate+0x90>
   82206:	2b20      	cmp	r3, #32
   82208:	d004      	beq.n	82214 <SystemCoreClockUpdate+0x98>
   8220a:	e006      	b.n	8221a <SystemCoreClockUpdate+0x9e>
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   8220c:	4a1f      	ldr	r2, [pc, #124]	; (8228c <SystemCoreClockUpdate+0x110>)
   8220e:	4b1c      	ldr	r3, [pc, #112]	; (82280 <SystemCoreClockUpdate+0x104>)
   82210:	601a      	str	r2, [r3, #0]
				break;
   82212:	e002      	b.n	8221a <SystemCoreClockUpdate+0x9e>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   82214:	4a1b      	ldr	r2, [pc, #108]	; (82284 <SystemCoreClockUpdate+0x108>)
   82216:	4b1a      	ldr	r3, [pc, #104]	; (82280 <SystemCoreClockUpdate+0x104>)
   82218:	601a      	str	r2, [r3, #0]
				break;
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
   8221a:	4b17      	ldr	r3, [pc, #92]	; (82278 <SystemCoreClockUpdate+0xfc>)
   8221c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8221e:	f003 0303 	and.w	r3, r3, #3
   82222:	2b02      	cmp	r3, #2
   82224:	d10d      	bne.n	82242 <SystemCoreClockUpdate+0xc6>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   82226:	4a14      	ldr	r2, [pc, #80]	; (82278 <SystemCoreClockUpdate+0xfc>)
   82228:	6a93      	ldr	r3, [r2, #40]	; 0x28
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   8222a:	6a92      	ldr	r2, [r2, #40]	; 0x28
   8222c:	4814      	ldr	r0, [pc, #80]	; (82280 <SystemCoreClockUpdate+0x104>)
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   8222e:	f3c3 410a 	ubfx	r1, r3, #16, #11
   82232:	6803      	ldr	r3, [r0, #0]
   82234:	fb01 3303 	mla	r3, r1, r3, r3
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   82238:	b2d2      	uxtb	r2, r2
   8223a:	fbb3 f3f2 	udiv	r3, r3, r2
   8223e:	6003      	str	r3, [r0, #0]
   82240:	e002      	b.n	82248 <SystemCoreClockUpdate+0xcc>
				                             CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock = SYS_UTMIPLL / 2U;
   82242:	4a13      	ldr	r2, [pc, #76]	; (82290 <SystemCoreClockUpdate+0x114>)
   82244:	4b0e      	ldr	r3, [pc, #56]	; (82280 <SystemCoreClockUpdate+0x104>)
   82246:	601a      	str	r2, [r3, #0]
		}
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
   82248:	4b0b      	ldr	r3, [pc, #44]	; (82278 <SystemCoreClockUpdate+0xfc>)
   8224a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8224c:	f003 0370 	and.w	r3, r3, #112	; 0x70
   82250:	2b70      	cmp	r3, #112	; 0x70
   82252:	d107      	bne.n	82264 <SystemCoreClockUpdate+0xe8>
		SystemCoreClock /= 3U;
   82254:	4a0a      	ldr	r2, [pc, #40]	; (82280 <SystemCoreClockUpdate+0x104>)
   82256:	6813      	ldr	r3, [r2, #0]
   82258:	490e      	ldr	r1, [pc, #56]	; (82294 <SystemCoreClockUpdate+0x118>)
   8225a:	fba1 1303 	umull	r1, r3, r1, r3
   8225e:	085b      	lsrs	r3, r3, #1
   82260:	6013      	str	r3, [r2, #0]
   82262:	4770      	bx	lr
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> 
   82264:	4b04      	ldr	r3, [pc, #16]	; (82278 <SystemCoreClockUpdate+0xfc>)
   82266:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   82268:	4905      	ldr	r1, [pc, #20]	; (82280 <SystemCoreClockUpdate+0x104>)
   8226a:	f3c2 1202 	ubfx	r2, r2, #4, #3
   8226e:	680b      	ldr	r3, [r1, #0]
   82270:	40d3      	lsrs	r3, r2
   82272:	600b      	str	r3, [r1, #0]
   82274:	4770      	bx	lr
   82276:	bf00      	nop
   82278:	400e0600 	.word	0x400e0600
   8227c:	400e1a10 	.word	0x400e1a10
   82280:	20070208 	.word	0x20070208
   82284:	00b71b00 	.word	0x00b71b00
   82288:	003d0900 	.word	0x003d0900
   8228c:	007a1200 	.word	0x007a1200
   82290:	0e4e1c00 	.word	0x0e4e1c00
   82294:	aaaaaaab 	.word	0xaaaaaaab

00082298 <main>:
 * Support and FAQ: visit <a href="http://www.atmel.com/design-support/">Atmel Support</a>
 */
#include <asf.h>

int main (void)
{
   82298:	b570      	push	{r4, r5, r6, lr}
	/* Insert system clock initialization code here (sysclk_init()). */
	sysclk_init();
   8229a:	4b0b      	ldr	r3, [pc, #44]	; (822c8 <main+0x30>)
   8229c:	4798      	blx	r3
	irq_initialize_vectors();
	cpu_irq_enable();
   8229e:	2601      	movs	r6, #1
   822a0:	4b0a      	ldr	r3, [pc, #40]	; (822cc <main+0x34>)
   822a2:	701e      	strb	r6, [r3, #0]
   822a4:	f3bf 8f5f 	dmb	sy
   822a8:	b662      	cpsie	i
	board_init();
   822aa:	4d09      	ldr	r5, [pc, #36]	; (822d0 <main+0x38>)
   822ac:	47a8      	blx	r5
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
		sleepmgr_locks[i] = 0;
   822ae:	4b09      	ldr	r3, [pc, #36]	; (822d4 <main+0x3c>)
   822b0:	2400      	movs	r4, #0
   822b2:	701c      	strb	r4, [r3, #0]
   822b4:	705c      	strb	r4, [r3, #1]
   822b6:	709c      	strb	r4, [r3, #2]
   822b8:	70dc      	strb	r4, [r3, #3]
   822ba:	711c      	strb	r4, [r3, #4]
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
   822bc:	715e      	strb	r6, [r3, #5]
	sleepmgr_init();
	board_init();
   822be:	47a8      	blx	r5

	/* Insert application code here, after the board has been initialized. */
	
	udc_start();
   822c0:	4b05      	ldr	r3, [pc, #20]	; (822d8 <main+0x40>)
   822c2:	4798      	blx	r3
}
   822c4:	4620      	mov	r0, r4
   822c6:	bd70      	pop	{r4, r5, r6, pc}
   822c8:	00081b91 	.word	0x00081b91
   822cc:	20070206 	.word	0x20070206
   822d0:	00081bf5 	.word	0x00081bf5
   822d4:	20070718 	.word	0x20070718
   822d8:	00080385 	.word	0x00080385

000822dc <__libc_init_array>:
   822dc:	b570      	push	{r4, r5, r6, lr}
   822de:	4e0f      	ldr	r6, [pc, #60]	; (8231c <__libc_init_array+0x40>)
   822e0:	4d0f      	ldr	r5, [pc, #60]	; (82320 <__libc_init_array+0x44>)
   822e2:	1b76      	subs	r6, r6, r5
   822e4:	10b6      	asrs	r6, r6, #2
   822e6:	bf18      	it	ne
   822e8:	2400      	movne	r4, #0
   822ea:	d005      	beq.n	822f8 <__libc_init_array+0x1c>
   822ec:	3401      	adds	r4, #1
   822ee:	f855 3b04 	ldr.w	r3, [r5], #4
   822f2:	4798      	blx	r3
   822f4:	42a6      	cmp	r6, r4
   822f6:	d1f9      	bne.n	822ec <__libc_init_array+0x10>
   822f8:	4e0a      	ldr	r6, [pc, #40]	; (82324 <__libc_init_array+0x48>)
   822fa:	4d0b      	ldr	r5, [pc, #44]	; (82328 <__libc_init_array+0x4c>)
   822fc:	f000 f896 	bl	8242c <_init>
   82300:	1b76      	subs	r6, r6, r5
   82302:	10b6      	asrs	r6, r6, #2
   82304:	bf18      	it	ne
   82306:	2400      	movne	r4, #0
   82308:	d006      	beq.n	82318 <__libc_init_array+0x3c>
   8230a:	3401      	adds	r4, #1
   8230c:	f855 3b04 	ldr.w	r3, [r5], #4
   82310:	4798      	blx	r3
   82312:	42a6      	cmp	r6, r4
   82314:	d1f9      	bne.n	8230a <__libc_init_array+0x2e>
   82316:	bd70      	pop	{r4, r5, r6, pc}
   82318:	bd70      	pop	{r4, r5, r6, pc}
   8231a:	bf00      	nop
   8231c:	00082438 	.word	0x00082438
   82320:	00082438 	.word	0x00082438
   82324:	00082440 	.word	0x00082440
   82328:	00082438 	.word	0x00082438

0008232c <register_fini>:
   8232c:	4b02      	ldr	r3, [pc, #8]	; (82338 <register_fini+0xc>)
   8232e:	b113      	cbz	r3, 82336 <register_fini+0xa>
   82330:	4802      	ldr	r0, [pc, #8]	; (8233c <register_fini+0x10>)
   82332:	f000 b805 	b.w	82340 <atexit>
   82336:	4770      	bx	lr
   82338:	00000000 	.word	0x00000000
   8233c:	0008234d 	.word	0x0008234d

00082340 <atexit>:
   82340:	4601      	mov	r1, r0
   82342:	2000      	movs	r0, #0
   82344:	4602      	mov	r2, r0
   82346:	4603      	mov	r3, r0
   82348:	f000 b816 	b.w	82378 <__register_exitproc>

0008234c <__libc_fini_array>:
   8234c:	b538      	push	{r3, r4, r5, lr}
   8234e:	4b08      	ldr	r3, [pc, #32]	; (82370 <__libc_fini_array+0x24>)
   82350:	4d08      	ldr	r5, [pc, #32]	; (82374 <__libc_fini_array+0x28>)
   82352:	1aed      	subs	r5, r5, r3
   82354:	10ac      	asrs	r4, r5, #2
   82356:	bf18      	it	ne
   82358:	18ed      	addne	r5, r5, r3
   8235a:	d005      	beq.n	82368 <__libc_fini_array+0x1c>
   8235c:	3c01      	subs	r4, #1
   8235e:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   82362:	4798      	blx	r3
   82364:	2c00      	cmp	r4, #0
   82366:	d1f9      	bne.n	8235c <__libc_fini_array+0x10>
   82368:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   8236c:	f000 b868 	b.w	82440 <_fini>
   82370:	0008244c 	.word	0x0008244c
   82374:	00082450 	.word	0x00082450

00082378 <__register_exitproc>:
   82378:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8237c:	4c25      	ldr	r4, [pc, #148]	; (82414 <__register_exitproc+0x9c>)
   8237e:	4606      	mov	r6, r0
   82380:	6825      	ldr	r5, [r4, #0]
   82382:	4688      	mov	r8, r1
   82384:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
   82388:	4692      	mov	sl, r2
   8238a:	4699      	mov	r9, r3
   8238c:	b3c4      	cbz	r4, 82400 <__register_exitproc+0x88>
   8238e:	6860      	ldr	r0, [r4, #4]
   82390:	281f      	cmp	r0, #31
   82392:	dc17      	bgt.n	823c4 <__register_exitproc+0x4c>
   82394:	1c41      	adds	r1, r0, #1
   82396:	b176      	cbz	r6, 823b6 <__register_exitproc+0x3e>
   82398:	eb04 0380 	add.w	r3, r4, r0, lsl #2
   8239c:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
   823a0:	f8d4 5188 	ldr.w	r5, [r4, #392]	; 0x188
   823a4:	2201      	movs	r2, #1
   823a6:	4082      	lsls	r2, r0
   823a8:	4315      	orrs	r5, r2
   823aa:	2e02      	cmp	r6, #2
   823ac:	f8c4 5188 	str.w	r5, [r4, #392]	; 0x188
   823b0:	f8c3 9108 	str.w	r9, [r3, #264]	; 0x108
   823b4:	d01e      	beq.n	823f4 <__register_exitproc+0x7c>
   823b6:	1c83      	adds	r3, r0, #2
   823b8:	6061      	str	r1, [r4, #4]
   823ba:	2000      	movs	r0, #0
   823bc:	f844 8023 	str.w	r8, [r4, r3, lsl #2]
   823c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   823c4:	4b14      	ldr	r3, [pc, #80]	; (82418 <__register_exitproc+0xa0>)
   823c6:	b303      	cbz	r3, 8240a <__register_exitproc+0x92>
   823c8:	f44f 70c8 	mov.w	r0, #400	; 0x190
   823cc:	f3af 8000 	nop.w
   823d0:	4604      	mov	r4, r0
   823d2:	b1d0      	cbz	r0, 8240a <__register_exitproc+0x92>
   823d4:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
   823d8:	2700      	movs	r7, #0
   823da:	e884 0088 	stmia.w	r4, {r3, r7}
   823de:	4638      	mov	r0, r7
   823e0:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   823e4:	2101      	movs	r1, #1
   823e6:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
   823ea:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
   823ee:	2e00      	cmp	r6, #0
   823f0:	d0e1      	beq.n	823b6 <__register_exitproc+0x3e>
   823f2:	e7d1      	b.n	82398 <__register_exitproc+0x20>
   823f4:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   823f8:	431a      	orrs	r2, r3
   823fa:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
   823fe:	e7da      	b.n	823b6 <__register_exitproc+0x3e>
   82400:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
   82404:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
   82408:	e7c1      	b.n	8238e <__register_exitproc+0x16>
   8240a:	f04f 30ff 	mov.w	r0, #4294967295
   8240e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   82412:	bf00      	nop
   82414:	00082428 	.word	0x00082428
   82418:	00000000 	.word	0x00000000
   8241c:	31303030 	.word	0x31303030
   82420:	00000000 	.word	0x00000000
   82424:	00000043 	.word	0x00000043

00082428 <_global_impure_ptr>:
   82428:	20070210                                ... 

0008242c <_init>:
   8242c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8242e:	bf00      	nop
   82430:	bcf8      	pop	{r3, r4, r5, r6, r7}
   82432:	bc08      	pop	{r3}
   82434:	469e      	mov	lr, r3
   82436:	4770      	bx	lr

00082438 <__init_array_start>:
   82438:	0008232d 	.word	0x0008232d

0008243c <__frame_dummy_init_array_entry>:
   8243c:	00080119                                ....

00082440 <_fini>:
   82440:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   82442:	bf00      	nop
   82444:	bcf8      	pop	{r3, r4, r5, r6, r7}
   82446:	bc08      	pop	{r3}
   82448:	469e      	mov	lr, r3
   8244a:	4770      	bx	lr

0008244c <__fini_array_start>:
   8244c:	000800f5 	.word	0x000800f5

Disassembly of section .relocate:

20070000 <SystemInit>:
__no_inline
RAMFUNC
void SystemInit(void)
{
	/* Set FWS according to SYS_BOARD_MCKR configuration */
	EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
20070000:	f44f 6380 	mov.w	r3, #1024	; 0x400
20070004:	4a20      	ldr	r2, [pc, #128]	; (20070088 <SystemInit+0x88>)
20070006:	6013      	str	r3, [r2, #0]
	EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
20070008:	f502 7200 	add.w	r2, r2, #512	; 0x200
2007000c:	6013      	str	r3, [r2, #0]

	/* Initialize main oscillator */
	if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
2007000e:	4b1f      	ldr	r3, [pc, #124]	; (2007008c <SystemInit+0x8c>)
20070010:	6a1b      	ldr	r3, [r3, #32]
20070012:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
20070016:	d107      	bne.n	20070028 <SystemInit+0x28>
		PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070018:	4a1d      	ldr	r2, [pc, #116]	; (20070090 <SystemInit+0x90>)
2007001a:	4b1c      	ldr	r3, [pc, #112]	; (2007008c <SystemInit+0x8c>)
2007001c:	621a      	str	r2, [r3, #32]
			                     CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN;
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
2007001e:	461a      	mov	r2, r3
20070020:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070022:	f013 0f01 	tst.w	r3, #1
20070026:	d0fb      	beq.n	20070020 <SystemInit+0x20>
		}
	}

	/* Switch to 3-20MHz Xtal oscillator */
	PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070028:	4a1a      	ldr	r2, [pc, #104]	; (20070094 <SystemInit+0x94>)
2007002a:	4b18      	ldr	r3, [pc, #96]	; (2007008c <SystemInit+0x8c>)
2007002c:	621a      	str	r2, [r3, #32]
	                           CKGR_MOR_MOSCRCEN | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCSEL;

	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
2007002e:	461a      	mov	r2, r3
20070030:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070032:	f413 3f80 	tst.w	r3, #65536	; 0x10000
20070036:	d0fb      	beq.n	20070030 <SystemInit+0x30>
	}
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | 
20070038:	4a14      	ldr	r2, [pc, #80]	; (2007008c <SystemInit+0x8c>)
2007003a:	6b13      	ldr	r3, [r2, #48]	; 0x30
2007003c:	f023 0303 	bic.w	r3, r3, #3
20070040:	f043 0301 	orr.w	r3, r3, #1
20070044:	6313      	str	r3, [r2, #48]	; 0x30
		                     PMC_MCKR_CSS_MAIN_CLK;
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070046:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070048:	f013 0f08 	tst.w	r3, #8
2007004c:	d0fb      	beq.n	20070046 <SystemInit+0x46>
	}

	/* Initialize PLLA */
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
2007004e:	4a12      	ldr	r2, [pc, #72]	; (20070098 <SystemInit+0x98>)
20070050:	4b0e      	ldr	r3, [pc, #56]	; (2007008c <SystemInit+0x8c>)
20070052:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
20070054:	461a      	mov	r2, r3
20070056:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070058:	f013 0f02 	tst.w	r3, #2
2007005c:	d0fb      	beq.n	20070056 <SystemInit+0x56>
	}

	/* Switch to main clock */
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
2007005e:	2211      	movs	r2, #17
20070060:	4b0a      	ldr	r3, [pc, #40]	; (2007008c <SystemInit+0x8c>)
20070062:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070064:	461a      	mov	r2, r3
20070066:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070068:	f013 0f08 	tst.w	r3, #8
2007006c:	d0fb      	beq.n	20070066 <SystemInit+0x66>
	}

	/* Switch to PLLA */
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
2007006e:	2212      	movs	r2, #18
20070070:	4b06      	ldr	r3, [pc, #24]	; (2007008c <SystemInit+0x8c>)
20070072:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070074:	461a      	mov	r2, r3
20070076:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070078:	f013 0f08 	tst.w	r3, #8
2007007c:	d0fb      	beq.n	20070076 <SystemInit+0x76>
	}

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
2007007e:	4a07      	ldr	r2, [pc, #28]	; (2007009c <SystemInit+0x9c>)
20070080:	4b07      	ldr	r3, [pc, #28]	; (200700a0 <SystemInit+0xa0>)
20070082:	601a      	str	r2, [r3, #0]
20070084:	4770      	bx	lr
20070086:	bf00      	nop
20070088:	400e0a00 	.word	0x400e0a00
2007008c:	400e0600 	.word	0x400e0600
20070090:	00370809 	.word	0x00370809
20070094:	01370809 	.word	0x01370809
20070098:	200d3f01 	.word	0x200d3f01
2007009c:	0501bd00 	.word	0x0501bd00
200700a0:	20070208 	.word	0x20070208

200700a4 <system_init_flash>:
__no_inline
RAMFUNC
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
200700a4:	4b1b      	ldr	r3, [pc, #108]	; (20070114 <system_init_flash+0x70>)
200700a6:	4298      	cmp	r0, r3
200700a8:	d806      	bhi.n	200700b8 <system_init_flash+0x14>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
200700aa:	2300      	movs	r3, #0
200700ac:	4a1a      	ldr	r2, [pc, #104]	; (20070118 <system_init_flash+0x74>)
200700ae:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
200700b0:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700b4:	6013      	str	r3, [r2, #0]
200700b6:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
200700b8:	4b18      	ldr	r3, [pc, #96]	; (2007011c <system_init_flash+0x78>)
200700ba:	4298      	cmp	r0, r3
200700bc:	d807      	bhi.n	200700ce <system_init_flash+0x2a>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
200700be:	f44f 7380 	mov.w	r3, #256	; 0x100
200700c2:	4a15      	ldr	r2, [pc, #84]	; (20070118 <system_init_flash+0x74>)
200700c4:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
200700c6:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700ca:	6013      	str	r3, [r2, #0]
200700cc:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
200700ce:	4b14      	ldr	r3, [pc, #80]	; (20070120 <system_init_flash+0x7c>)
200700d0:	4298      	cmp	r0, r3
200700d2:	d807      	bhi.n	200700e4 <system_init_flash+0x40>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
200700d4:	f44f 7300 	mov.w	r3, #512	; 0x200
200700d8:	4a0f      	ldr	r2, [pc, #60]	; (20070118 <system_init_flash+0x74>)
200700da:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
200700dc:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700e0:	6013      	str	r3, [r2, #0]
200700e2:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
200700e4:	4b0f      	ldr	r3, [pc, #60]	; (20070124 <system_init_flash+0x80>)
200700e6:	4298      	cmp	r0, r3
200700e8:	d807      	bhi.n	200700fa <system_init_flash+0x56>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
200700ea:	f44f 7340 	mov.w	r3, #768	; 0x300
200700ee:	4a0a      	ldr	r2, [pc, #40]	; (20070118 <system_init_flash+0x74>)
200700f0:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
200700f2:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700f6:	6013      	str	r3, [r2, #0]
200700f8:	4770      	bx	lr
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
200700fa:	4b0b      	ldr	r3, [pc, #44]	; (20070128 <system_init_flash+0x84>)
200700fc:	4298      	cmp	r0, r3
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
200700fe:	bf94      	ite	ls
20070100:	f44f 6380 	movls.w	r3, #1024	; 0x400
		EFC1->EEFC_FMR = EEFC_FMR_FWS(4);	
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
20070104:	f44f 63a0 	movhi.w	r3, #1280	; 0x500
20070108:	4a03      	ldr	r2, [pc, #12]	; (20070118 <system_init_flash+0x74>)
2007010a:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(5);
2007010c:	f502 7200 	add.w	r2, r2, #512	; 0x200
20070110:	6013      	str	r3, [r2, #0]
20070112:	4770      	bx	lr
20070114:	0121eabf 	.word	0x0121eabf
20070118:	400e0a00 	.word	0x400e0a00
2007011c:	02faf07f 	.word	0x02faf07f
20070120:	03d08fff 	.word	0x03d08fff
20070124:	04c4b3ff 	.word	0x04c4b3ff
20070128:	055d4a7f 	.word	0x055d4a7f

2007012c <udi_hid_kbd_report_desc>:
2007012c:	06090105 070501a1 e729e019 01250015     ..........)...%.
2007013c:	08950175 01810281 65290019 65250015     u.........)e..%e
2007014c:	06950875 08050081 05290119 01250015     u.........)...%.
2007015c:	05950175 03950291 00c00191              u...........

20070168 <udi_api_hid_kbd>:
20070168:	0008019d 00080151 000801cd 00080155     ....Q.......U...
20070178:	00000000                                ....

2007017c <udc_string_product_name>:
2007017c:	65646f4d 53554d6c 00000042              ModelMUSB...

20070188 <udc_string_manufacturer_name>:
20070188:	6977654c 6f502073 72657472 00000000     Lewis Porter....

20070198 <udc_string_desc>:
20070198:	00000300 00000000 00000000 00000000     ................
	...

200701b4 <udc_string_desc_languageid>:
200701b4:	04090304                                ....

200701b8 <udc_desc>:
200701b8:	00220209 80000101 00040932 00030100     ..".....2.......
200701c8:	21090001 01000111 07003b22 08038105     ...!....";......
200701d8:	00000200                                ....

200701dc <udc_config_fshs>:
200701dc:	200701b8 200701f0                       ... ... 

200701e4 <udc_config>:
200701e4:	200701f4 200701dc 00000000              ... ... ....

200701f0 <udi_apis>:
200701f0:	20070168                                h.. 

200701f4 <udc_device_desc>:
200701f4:	02000112 08000000 48256666 02010100     ........ff%H....
20070204:	00010103                                         ..

20070206 <g_interrupt_enabled>:
20070206:	09000001                                         ..

20070208 <SystemCoreClock>:
20070208:	003d0900 00000000                       ..=.....

20070210 <impure_data>:
20070210:	00000000 200704fc 20070564 200705cc     ....... d.. ... 
	...
20070244:	00082424 00000000 00000000 00000000     $$..............
	...
200702b8:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
200702c8:	0005deec 0000000b 00000000 00000000     ................
	...
